# 1 "p_spec.c"
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

static const char
rcsid[] = "$Id: p_spec.c,v 1.57 1998/08/14 11:27:27 jim Exp $";

# 1 "doomstat.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 




 
 
# 1 "doomdata.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 




 
# 1 "doomtype.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 







 



typedef enum {false, true} boolean;

typedef unsigned char byte;


# 1 "c:/djgpp/include/values.h" 1 3
 
























































# 46 "doomtype.h" 2





 
 
 
 
 
 
 
 
 
 
 
 
 
# 36 "doomdata.h" 2


 
 
 
 
 

 
 
enum {
  ML_LABEL,              
  ML_THINGS,             
  ML_LINEDEFS,           
  ML_SIDEDEFS,           
  ML_VERTEXES,           
  ML_SEGS,               
  ML_SSECTORS,           
  ML_NODES,              
  ML_SECTORS,            
  ML_REJECT,             
  ML_BLOCKMAP            
};

 
typedef struct {
  short x,y;
} mapvertex_t;

 
 
typedef struct {
  short textureoffset;
  short rowoffset;
  char  toptexture[8];
  char  bottomtexture[8];
  char  midtexture[8];
  short sector;   
} mapsidedef_t;

 

typedef struct {
  short v1;
  short v2;
  short flags;
  short special;
  short tag;
  short sidenum[2];   
} maplinedef_t;

 
 
 

 


 


 


 
 
 
 
 
 
 
 

 


 


 


 


 


 


 
 


 
typedef struct {
  short floorheight;
  short ceilingheight;
  char  floorpic[8];
  char  ceilingpic[8];
  short lightlevel;
  short special;
  short tag;
} mapsector_t;

 
typedef struct {
  short numsegs;
  short firstseg;     
} mapsubsector_t;

 
 
typedef struct {
  short v1;
  short v2;
  short angle;
  short linedef;
  short side;
  short offset;
} mapseg_t;

 

 


typedef struct {
  short x;   
  short y;
  short dx;
  short dy;
   
  short bbox[2][4];
   
  unsigned short children[2];
} mapnode_t;

 
 
typedef struct {
  short x;
  short y;
  short angle;
  short type;
  short options;
} mapthing_t;



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
# 40 "doomstat.h" 2

# 1 "d_net.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 





# 1 "d_player.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 






 
 
 
 
# 1 "d_items.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 





# 1 "doomdef.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 




 





 
# 1 "z_zone.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 








 







 
 

# 1 "c:/djgpp/include/stdio.h" 1 3
 










# 1 "c:/djgpp/include/sys/djtypes.h" 1 3
 















# 12 "c:/djgpp/include/stdio.h" 2 3

  
















typedef void *va_list; 


typedef long unsigned int size_t; 



 


   
typedef struct {
  int   _cnt;
  char *_ptr;
  char *_base;
  int   _bufsiz;
  int   _flag;
  int   _file;
  char *_name_to_remove;
} FILE;

typedef unsigned long		fpos_t;

extern FILE __dj_stdin, __dj_stdout, __dj_stderr;




void	clearerr(FILE *_stream);
int	fclose(FILE *_stream);
int	feof(FILE *_stream);
int	ferror(FILE *_stream);
int	fflush(FILE *_stream);
int	fgetc(FILE *_stream);
int	fgetpos(FILE *_stream, fpos_t *_pos);
char *	fgets(char *_s, int _n, FILE *_stream);
FILE *	fopen(const char *_filename, const char *_mode);
int	fprintf(FILE *_stream, const char *_format, ...);
int	fputc(int _c, FILE *_stream);
int	fputs(const char *_s, FILE *_stream);
size_t	fread(void *_ptr, size_t _size, size_t _nelem, FILE *_stream);
FILE *	freopen(const char *_filename, const char *_mode, FILE *_stream);
int	fscanf(FILE *_stream, const char *_format, ...);
int	fseek(FILE *_stream, long _offset, int _mode);
int	fsetpos(FILE *_stream, const fpos_t *_pos);
long	ftell(FILE *_stream);
size_t	fwrite(const void *_ptr, size_t _size, size_t _nelem, FILE *_stream);
int	getc(FILE *_stream);
int	getchar(void);
char *	gets(char *_s);
void	perror(const char *_s);
int	printf(const char *_format, ...);
int	putc(int _c, FILE *_stream);
int	putchar(int _c);
int	puts(const char *_s);
int	remove(const char *_filename);
int	rename(const char *_old, const char *_new);
void	rewind(FILE *_stream);
int	scanf(const char *_format, ...);
void	setbuf(FILE *_stream, char *_buf);
int	setvbuf(FILE *_stream, char *_buf, int _mode, size_t _size);
int	sprintf(char *_s, const char *_format, ...);
int	sscanf(const char *_s, const char *_format, ...);
FILE *	tmpfile(void);
char *	tmpnam(char *_s);
int	ungetc(int _c, FILE *_stream);
int	vfprintf(FILE *_stream, const char *_format, va_list _ap);
int	vprintf(const char *_format, va_list _ap);
int	vsprintf(char *_s, const char *_format, va_list _ap);





 

int	fileno(FILE *_stream);
FILE *	fdopen(int _fildes, const char *_type);
int	pclose(FILE *_pf);
FILE *	popen(const char *_command, const char *_mode);



extern FILE __dj_stdprn, __dj_stdaux;



void	_djstat_describe_lossage(FILE *_to_where);
int	_doprnt(const char *_fmt, va_list _args, FILE *_f);
int	_doscan(FILE *_f, const char *_fmt, void **_argp);
int	_doscan_low(FILE *, int (*)(FILE *_get), int (*_unget)(int, FILE *), const char *_fmt, void **_argp);
int	fpurge(FILE *_f);
int	getw(FILE *_f);
int	mkstemp(char *_template);
char *	mktemp(char *_template);
int	putw(int _v, FILE *_f);
void	setbuffer(FILE *_f, void *_buf, int _size);
void	setlinebuf(FILE *_f);
char *	tempnam(const char *_dir, const char *_prefix);
int	_rename(const char *_old, const char *_new);	 













# 53 "z_zone.h" 2

# 1 "c:/djgpp/include/stdlib.h" 1 3
 










  






extern int __dj_mb_cur_max;

typedef struct {
  int quot;
  int rem;
} div_t;

typedef struct {
  long quot;
  long rem;
} ldiv_t;

 


typedef int wchar_t; 



void	abort(void) __attribute__((noreturn));
int	abs(int _i);
int	atexit(void (*_func)(void));
double	atof(const char *_s);
int	atoi(const char *_s);
long	atol(const char *_s);
void *	bsearch(const void *_key, const void *_base, size_t _nelem,
		size_t _size, int (*_cmp)(const void *_ck, const void *_ce));
void *	calloc(size_t _nelem, size_t _size);
div_t	div(int _numer, int _denom);
void	exit(int _status) __attribute__((noreturn));
void	free(void *_ptr);
char *	getenv(const char *_name);
long	labs(long _i);
ldiv_t	ldiv(long _numer, long _denom);
void *	malloc(size_t _size);
int	mblen(const char *_s, size_t _n);
size_t	mbstowcs(wchar_t *_wcs, const char *_s, size_t _n);
int	mbtowc(wchar_t *_pwc, const char *_s, size_t _n);
void	qsort(void *_base, size_t _nelem, size_t _size,
	      int (*_cmp)(const void *_e1, const void *_e2));
int	rand(void);
void *	realloc(void *_ptr, size_t _size);
void	srand(unsigned _seed);
double	strtod(const char *_s, char **_endptr);
long	strtol(const char *_s, char **_endptr, int _base);
unsigned long	strtoul(const char *_s, char **_endptr, int _base);
int	system(const char *_s);
size_t	wcstombs(char *_s, const wchar_t *_wcs, size_t _n);
int	wctomb(char *_s, wchar_t _wchar);





typedef struct {
  long long quot;
  long long rem;
} lldiv_t;

void *		alloca(size_t _size);
long double	_atold(const char *_s);
long long	atoll(const char *_s);
void		cfree(void *_ptr);
char *		getpass(const char *_prompt);
int		getlongpass(const char *_prompt, char *_buffer, int _max_len);
char *		itoa(int value, char *buffer, int radix);
long long	llabs(long long _i);
lldiv_t		lldiv(long long _numer, long long _denom);
int		putenv(const char *_val);
int		setenv(const char *_var, const char *_val, int _replace);
long double	_strtold(const char *_s, char **_endptr);
long long	strtoll(const char *_s, char **_endptr, int _base);
unsigned long long strtoull(const char *_s, char **_endptr, int _base);
void		swab(const void *from, void *to, int nbytes);





 
char  *	initstate (unsigned _seed, char *_arg_state, int _n);
char  *	setstate(char *_arg_state);
long	random(void);
int	srandom(int _seed);

 















extern int __system_flags;

extern int _shell_command  (const char *_prog, const char *_cmdline);
extern int _is_unixy_shell (const char *_prog);
extern int _is_dos_shell   (const char *_prog);













# 54 "z_zone.h" 2

# 1 "c:/djgpp/include/string.h" 1 3
 










  

 



void *	memchr(const void *_s, int _c, size_t _n);
int	memcmp(const void *_s1, const void *_s2, size_t _n);
void *	memcpy(void *_dest, const void *_src, size_t _n);
void *	memmove(void *_s1, const void *_s2, size_t _n);
void *	memset(void *_s, int _c, size_t _n);
char *	strcat(char *_s1, const char *_s2);
char *	strchr(const char *_s, int _c);
int	strcmp(const char *_s1, const char *_s2);
int	strcoll(const char *_s1, const char *_s2);
char *	strcpy(char *_s1, const char *_s2);
size_t	strcspn(const char *_s1, const char *_s2);
char *	strerror(int _errcode);
size_t	strlen(const char *_s);
char *	strncat(char *_s1, const char *_s2, size_t _n);
int	strncmp(const char *_s1, const char *_s2, size_t _n);
char *	strncpy(char *_s1, const char *_s2, size_t _n);
char *	strpbrk(const char *_s1, const char *_s2);
char *	strrchr(const char *_s, int _c);
size_t	strspn(const char *_s1, const char *_s2);
char *	strstr(const char *_s1, const char *_s2);
char *	strtok(char *_s1, const char *_s2);
size_t	strxfrm(char *_s1, const char *_s2, size_t _n);





# 1 "c:/djgpp/include/sys/movedata.h" 1 3
 















 



 
void dosmemget(unsigned long _offset, size_t _length, void *_buffer);
void dosmemput(const void *_buffer, size_t _length, unsigned long _offset);

 
void _dosmemgetb(unsigned long _offset, size_t _xfers, void *_buffer);
void _dosmemgetw(unsigned long _offset, size_t _xfers, void *_buffer);
void _dosmemgetl(unsigned long _offset, size_t _xfers, void *_buffer);
void _dosmemputb(const void *_buffer, size_t _xfers, unsigned long _offset);
void _dosmemputw(const void *_buffer, size_t _xfers, unsigned long _offset);
void _dosmemputl(const void *_buffer, size_t _xfers, unsigned long _offset);


 
void movedata(unsigned _source_selector, unsigned _source_offset,
	       unsigned _dest_selector, unsigned _dest_offset,
	       size_t _length);

 
void _movedatab(unsigned, unsigned, unsigned, unsigned, size_t);
void _movedataw(unsigned, unsigned, unsigned, unsigned, size_t);
void _movedatal(unsigned, unsigned, unsigned, unsigned, size_t);
  












# 45 "c:/djgpp/include/string.h" 2 3


int	bcmp(const void *_ptr1, const void *_ptr2, int _length);
void *	bcopy(const void *_a, void *_b, size_t _len);
void *	bzero(void *ptr, size_t _len);
int	ffs(int _mask);
char *  index(const char *_string, int _c);
void *	memccpy(void *_to, const void *_from, int c, size_t n);
char *  rindex(const char *_string, int _c);
char *	stpcpy(char *_dest, const char *_src);
char *	strdup(const char *_s);
char *	strlwr(char *_s);
int	strcasecmp(const char *_s1, const char *_s2);
int	stricmp(const char *_s1, const char *_s2);
int	strncasecmp(const char *_s1, const char *_s2, size_t _n);
int	strnicmp(const char *_s1, const char *_s2, size_t _n);
char *	strsep(char **_stringp, const char *_delim);
char *	strupr(char *_s);













# 55 "z_zone.h" 2

# 1 "c:/djgpp/include/assert.h" 1 3
 

















void	__dj_assert(const char *,const char *,int);








# 56 "z_zone.h" 2


 
 

enum {PU_FREE, PU_STATIC, PU_SOUND, PU_MUSIC, PU_LEVEL, PU_LEVSPEC, PU_CACHE,
        PU_MAX};



void *(Z_Malloc)(size_t size, int tag, void **ptr, const char *, int);
void (Z_Free)(void *ptr, const char *, int);
void (Z_FreeTags)(int lowtag, int hightag, const char *, int);
void (Z_ChangeTag)(void *ptr, int tag, const char *, int);
void (Z_Init)(void);
void *(Z_Calloc)(size_t n, size_t n2, int tag, void **user, const char *, int);
void *(Z_Realloc)(void *p, size_t n, int tag, void **user, const char *, int);
char *(Z_Strdup)(const char *s, int tag, void **user, const char *, int);
void (Z_CheckHeap)(const char *,int);    
void Z_DumpHistory(char *);
















 
void dprintf(const char *, ...) __attribute__((format(printf,1,2)));

void Z_ZoneHistory(char *);



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
# 41 "doomdef.h" 2





# 1 "c:/djgpp/include/ctype.h" 1 3
 









int	isalnum(int c);
int	isalpha(int c);
int	iscntrl(int c);
int	isdigit(int c);
int	isgraph(int c);
int	islower(int c);
int	isprint(int c);
int	ispunct(int c);
int	isspace(int c);
int	isupper(int c);
int	isxdigit(int c);
int	tolower(int c);
int	toupper(int c);


# 1 "c:/djgpp/include/inlines/ctype.ha" 1 3















extern unsigned short __dj_ctype_flags[];
extern unsigned char __dj_ctype_toupper[];
extern unsigned char __dj_ctype_tolower[];

















# 26 "c:/djgpp/include/ctype.h" 2 3


  




int	isascii(int c);
int	toascii(int c);


# 1 "c:/djgpp/include/inlines/ctype.hd" 1 3







# 37 "c:/djgpp/include/ctype.h" 2 3












# 46 "doomdef.h" 2

# 1 "c:/djgpp/include/limits.h" 1 3
 














































 
 













 



 
















# 47 "doomdef.h" 2


# 1 "m_swap.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 









 
 
 
 
 
 

 


__inline__

static short SHORT(short x)
{
  return (((unsigned char *) &x)[1]<< 8) +
          ((unsigned char *) &x)[0];
}

 


__inline__

static long LONG(long x)
{
  return (((unsigned char *) &x)[3]<<24) +
         (((unsigned char *) &x)[2]<<16) +
         (((unsigned char *) &x)[1]<< 8) +
          ((unsigned char *) &x)[0];
} 



 
 
 
 
 
 
 
 
 
 
 
 
 
 
# 49 "doomdef.h" 2

# 1 "version.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 







 
enum { VERSION =  202 };

extern const char version_date[];



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
# 50 "doomdef.h" 2


 
 
typedef enum {
  shareware,     
  registered,    
  commercial,    
  retail,        
  indetermined   
} GameMode_t;

 
typedef enum {
  doom,          
  doom2,         
  pack_tnt,      
  pack_plut,     
  none
} GameMission_t;

 
typedef enum {
  english,
  french,
  german,
  unknown
} Language_t;

 
 
 



 
 
 
 




 
 
 







 


 
 






 


 
 

typedef enum {
  GS_LEVEL,
  GS_INTERMISSION,
  GS_FINALE,
  GS_DEMOSCREEN
} gamestate_t;

 
 
 
 

 



 


typedef enum {
  sk_none=-1,  
  sk_baby=0,
  sk_easy,
  sk_medium,
  sk_hard,
  sk_nightmare
} skill_t;

 
 
 

typedef enum {
  it_bluecard,
  it_yellowcard,
  it_redcard,
  it_blueskull,
  it_yellowskull,
  it_redskull,
  NUMCARDS
} card_t;

 
 
typedef enum {
  wp_fist,
  wp_pistol,
  wp_shotgun,
  wp_chaingun,
  wp_missile,
  wp_plasma,
  wp_bfg,
  wp_chainsaw,
  wp_supershotgun,

  NUMWEAPONS,
  wp_nochange               
} weapontype_t;

 
typedef enum {
  am_clip,     
  am_shell,    
  am_cell,     
  am_misl,     
  NUMAMMO,
  am_noammo    
} ammotype_t;

 
typedef enum {
  pw_invulnerability,
  pw_strength,
  pw_invisibility,
  pw_ironfeet,
  pw_allmap,
  pw_infrared,
  NUMPOWERS
} powertype_t;

 
typedef enum {
  INVULNTICS  = (30* 35 ),
  INVISTICS   = (60* 35 ),
  INFRATICS   = (120* 35 ),
  IRONTICS    = (60* 35 )
} powerduration_t;

 
 
 






























 








 



 
 
 

typedef enum {
  ss_none,
  ss_keys,
  ss_weap,
  ss_stat,
  ss_auto,
  ss_enem,
  ss_mess,
  ss_chat,
  ss_max
} ss_types;

 
 
 
 
 







 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
# 34 "d_items.h" 2







 
typedef struct
{
  ammotype_t  ammo;
  int         upstate;
  int         downstate;
  int         readystate;
  int         atkstate;
  int         flashstate;

} weaponinfo_t;

extern  weaponinfo_t    weaponinfo[NUMWEAPONS];



 
 
 
 
 
 
 
 
 
 
 
 
 
 
# 39 "d_player.h" 2

# 1 "p_pspr.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 




 
 

# 1 "m_fixed.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 













# 1 "i_system.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 




# 1 "d_ticcmd.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 











 
 
 
 
typedef struct
{
    char	forwardmove;	 
    char	sidemove;	 
    short	angleturn;	 
    short	consistancy;	 
    byte	chatchar;
    byte	buttons;
} ticcmd_t;





 
 
 
 
 
 
 
 
 
 
 
# 33 "i_system.h" 2






 
void I_Init(void);

 
 
 

int (*I_GetTime)();            
int I_GetTime_RealTime();      
int I_GetTime_Adaptive(void);  
extern int GetTime_Scale;

 
 
 
 
 
 
 
 

void I_StartFrame (void);

 
 
 
 
 

void I_StartTic (void);

 
 
 

 
 
 
 

ticcmd_t* I_BaseTiccmd (void);

 

void I_Quit (void);

 




 
 
void I_Error(const char *error, ...) __attribute__((format(printf,1,2)));

extern int mousepresent;                 

void I_EndDoom(void);          

 



extern struct keyboard_queue_s {
  volatile int head,tail,queue[256 ];
} keyboard_queue;



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
# 42 "m_fixed.h" 2


 
 
 




typedef int fixed_t;

 
 
 

 
 





 
 
 



 

__inline__ static fixed_t FixedMul(fixed_t a, fixed_t b)
{
  fixed_t result;

  asm("  imull %2 ;"
      "  shrdl $16,%%edx,%0 ;"
      : "=a,=a" (result)            
      : "0,0" (a),                  
        "m,r" (b)                   
      : "%edx", "%cc"               
      );

  return result;
}










 
 
 



 

__inline__ static fixed_t FixedDiv(fixed_t a, fixed_t b)
{
  fixed_t result;

  if (({int _s,_t=( a ); asm(" cdq": "=d" (_s): "a" (_t)); (_t^_s)-_s;})  >> 14 >= ({int _s,_t=( b ); asm(" cdq": "=d" (_s): "a" (_t)); (_t^_s)-_s;}) )
    return (a^b)<0 ? ((int)0x80000000L)  : ((int)0x7fffffff) ;

  asm(" movl %0, %%edx ;"
      " sall $16,%%eax ;"
      " sarl $16,%%edx ;"
      " idivl %2 ;"
      : "=a,=a" (result)     
      : "0,0" (a),           
        "m,r" (b)            
      : "%edx", "%cc"        
      );

  return result;
}

# 132 "m_fixed.h"




 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

# 36 "p_pspr.h" 2

# 1 "tables.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 









 


 
extern const fixed_t finesine[5* 8192 /4];

 
extern const fixed_t *const finecosine;

 
extern const fixed_t finetangent[8192 /2];

 









typedef unsigned angle_t;

 
 

extern const angle_t tantoangle[2048 +1];

 
int SlopeDiv(unsigned num, unsigned den);



 
 
 
 
 
 
 
 
 
 
 
 
 
# 37 "p_pspr.h" 2


 
 
 
 
 

# 1 "info.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 




 
# 1 "d_think.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 












 
 
 
 
 
 
typedef  void (*actionf_v)();
typedef  void (*actionf_p1)( void* );
typedef  void (*actionf_p2)( void*, void* );

 
 
typedef union
{
  actionf_p1    acp1;
  actionf_v     acv;
  actionf_p2    acp2;

} actionf_t;

 
 
 
typedef actionf_t  think_t;


 
typedef struct thinker_s
{
  struct thinker_s*   prev;
  struct thinker_s*   next;
  think_t             function;
    
} thinker_t;




 
 
 
 
 
 
 
 
 
 
 
 
 
 
# 36 "info.h" 2


 
 
 
typedef enum                                  
{
  SPR_TROO,
  SPR_SHTG,
  SPR_PUNG,
  SPR_PISG,
  SPR_PISF,
  SPR_SHTF,
  SPR_SHT2,
  SPR_CHGG,
  SPR_CHGF,
  SPR_MISG,
  SPR_MISF,
  SPR_SAWG,
  SPR_PLSG,
  SPR_PLSF,
  SPR_BFGG,
  SPR_BFGF,
  SPR_BLUD,
  SPR_PUFF,
  SPR_BAL1,
  SPR_BAL2,
  SPR_PLSS,
  SPR_PLSE,
  SPR_MISL,
  SPR_BFS1,
  SPR_BFE1,
  SPR_BFE2,
  SPR_TFOG,
  SPR_IFOG,
  SPR_PLAY,
  SPR_POSS,
  SPR_SPOS,
  SPR_VILE,
  SPR_FIRE,
  SPR_FATB,
  SPR_FBXP,
  SPR_SKEL,
  SPR_MANF,
  SPR_FATT,
  SPR_CPOS,
  SPR_SARG,
  SPR_HEAD,
  SPR_BAL7,
  SPR_BOSS,
  SPR_BOS2,
  SPR_SKUL,
  SPR_SPID,
  SPR_BSPI,
  SPR_APLS,
  SPR_APBX,
  SPR_CYBR,
  SPR_PAIN,
  SPR_SSWV,
  SPR_KEEN,
  SPR_BBRN,
  SPR_BOSF,
  SPR_ARM1,
  SPR_ARM2,
  SPR_BAR1,
  SPR_BEXP,
  SPR_FCAN,
  SPR_BON1,
  SPR_BON2,
  SPR_BKEY,
  SPR_RKEY,
  SPR_YKEY,
  SPR_BSKU,
  SPR_RSKU,
  SPR_YSKU,
  SPR_STIM,
  SPR_MEDI,
  SPR_SOUL,
  SPR_PINV,
  SPR_PSTR,
  SPR_PINS,
  SPR_MEGA,
  SPR_SUIT,
  SPR_PMAP,
  SPR_PVIS,
  SPR_CLIP,
  SPR_AMMO,
  SPR_ROCK,
  SPR_BROK,
  SPR_CELL,
  SPR_CELP,
  SPR_SHEL,
  SPR_SBOX,
  SPR_BPAK,
  SPR_BFUG,
  SPR_MGUN,
  SPR_CSAW,
  SPR_LAUN,
  SPR_PLAS,
  SPR_SHOT,
  SPR_SGN2,
  SPR_COLU,
  SPR_SMT2,
  SPR_GOR1,
  SPR_POL2,
  SPR_POL5,
  SPR_POL4,
  SPR_POL3,
  SPR_POL1,
  SPR_POL6,
  SPR_GOR2,
  SPR_GOR3,
  SPR_GOR4,
  SPR_GOR5,
  SPR_SMIT,
  SPR_COL1,
  SPR_COL2,
  SPR_COL3,
  SPR_COL4,
  SPR_CAND,
  SPR_CBRA,
  SPR_COL6,
  SPR_TRE1,
  SPR_TRE2,
  SPR_ELEC,
  SPR_CEYE,
  SPR_FSKU,
  SPR_COL5,
  SPR_TBLU,
  SPR_TGRN,
  SPR_TRED,
  SPR_SMBT,
  SPR_SMGT,
  SPR_SMRT,
  SPR_HDB1,
  SPR_HDB2,
  SPR_HDB3,
  SPR_HDB4,
  SPR_HDB5,
  SPR_HDB6,
  SPR_POB1,
  SPR_POB2,
  SPR_BRS1,
  SPR_TLMP,
  SPR_TLP2,
  SPR_TNT1,  

  NUMSPRITES   

} spritenum_t;

 
 
 
typedef enum
{
  S_NULL,
  S_LIGHTDONE,
  S_PUNCH,
  S_PUNCHDOWN,
  S_PUNCHUP,
  S_PUNCH1,
  S_PUNCH2,
  S_PUNCH3,
  S_PUNCH4,
  S_PUNCH5,
  S_PISTOL,
  S_PISTOLDOWN,
  S_PISTOLUP,
  S_PISTOL1,
  S_PISTOL2,
  S_PISTOL3,
  S_PISTOL4,
  S_PISTOLFLASH,
  S_SGUN,
  S_SGUNDOWN,
  S_SGUNUP,
  S_SGUN1,
  S_SGUN2,
  S_SGUN3,
  S_SGUN4,
  S_SGUN5,
  S_SGUN6,
  S_SGUN7,
  S_SGUN8,
  S_SGUN9,
  S_SGUNFLASH1,
  S_SGUNFLASH2,
  S_DSGUN,
  S_DSGUNDOWN,
  S_DSGUNUP,
  S_DSGUN1,
  S_DSGUN2,
  S_DSGUN3,
  S_DSGUN4,
  S_DSGUN5,
  S_DSGUN6,
  S_DSGUN7,
  S_DSGUN8,
  S_DSGUN9,
  S_DSGUN10,
  S_DSNR1,
  S_DSNR2,
  S_DSGUNFLASH1,
  S_DSGUNFLASH2,
  S_CHAIN,
  S_CHAINDOWN,
  S_CHAINUP,
  S_CHAIN1,
  S_CHAIN2,
  S_CHAIN3,
  S_CHAINFLASH1,
  S_CHAINFLASH2,
  S_MISSILE,
  S_MISSILEDOWN,
  S_MISSILEUP,
  S_MISSILE1,
  S_MISSILE2,
  S_MISSILE3,
  S_MISSILEFLASH1,
  S_MISSILEFLASH2,
  S_MISSILEFLASH3,
  S_MISSILEFLASH4,
  S_SAW,
  S_SAWB,
  S_SAWDOWN,
  S_SAWUP,
  S_SAW1,
  S_SAW2,
  S_SAW3,
  S_PLASMA,
  S_PLASMADOWN,
  S_PLASMAUP,
  S_PLASMA1,
  S_PLASMA2,
  S_PLASMAFLASH1,
  S_PLASMAFLASH2,
  S_BFG,
  S_BFGDOWN,
  S_BFGUP,
  S_BFG1,
  S_BFG2,
  S_BFG3,
  S_BFG4,
  S_BFGFLASH1,
  S_BFGFLASH2,
  S_BLOOD1,
  S_BLOOD2,
  S_BLOOD3,
  S_PUFF1,
  S_PUFF2,
  S_PUFF3,
  S_PUFF4,
  S_TBALL1,
  S_TBALL2,
  S_TBALLX1,
  S_TBALLX2,
  S_TBALLX3,
  S_RBALL1,
  S_RBALL2,
  S_RBALLX1,
  S_RBALLX2,
  S_RBALLX3,
  S_PLASBALL,
  S_PLASBALL2,
  S_PLASEXP,
  S_PLASEXP2,
  S_PLASEXP3,
  S_PLASEXP4,
  S_PLASEXP5,
  S_ROCKET,
  S_BFGSHOT,
  S_BFGSHOT2,
  S_BFGLAND,
  S_BFGLAND2,
  S_BFGLAND3,
  S_BFGLAND4,
  S_BFGLAND5,
  S_BFGLAND6,
  S_BFGEXP,
  S_BFGEXP2,
  S_BFGEXP3,
  S_BFGEXP4,
  S_EXPLODE1,
  S_EXPLODE2,
  S_EXPLODE3,
  S_TFOG,
  S_TFOG01,
  S_TFOG02,
  S_TFOG2,
  S_TFOG3,
  S_TFOG4,
  S_TFOG5,
  S_TFOG6,
  S_TFOG7,
  S_TFOG8,
  S_TFOG9,
  S_TFOG10,
  S_IFOG,
  S_IFOG01,
  S_IFOG02,
  S_IFOG2,
  S_IFOG3,
  S_IFOG4,
  S_IFOG5,
  S_PLAY,
  S_PLAY_RUN1,
  S_PLAY_RUN2,
  S_PLAY_RUN3,
  S_PLAY_RUN4,
  S_PLAY_ATK1,
  S_PLAY_ATK2,
  S_PLAY_PAIN,
  S_PLAY_PAIN2,
  S_PLAY_DIE1,
  S_PLAY_DIE2,
  S_PLAY_DIE3,
  S_PLAY_DIE4,
  S_PLAY_DIE5,
  S_PLAY_DIE6,
  S_PLAY_DIE7,
  S_PLAY_XDIE1,
  S_PLAY_XDIE2,
  S_PLAY_XDIE3,
  S_PLAY_XDIE4,
  S_PLAY_XDIE5,
  S_PLAY_XDIE6,
  S_PLAY_XDIE7,
  S_PLAY_XDIE8,
  S_PLAY_XDIE9,
  S_POSS_STND,
  S_POSS_STND2,
  S_POSS_RUN1,
  S_POSS_RUN2,
  S_POSS_RUN3,
  S_POSS_RUN4,
  S_POSS_RUN5,
  S_POSS_RUN6,
  S_POSS_RUN7,
  S_POSS_RUN8,
  S_POSS_ATK1,
  S_POSS_ATK2,
  S_POSS_ATK3,
  S_POSS_PAIN,
  S_POSS_PAIN2,
  S_POSS_DIE1,
  S_POSS_DIE2,
  S_POSS_DIE3,
  S_POSS_DIE4,
  S_POSS_DIE5,
  S_POSS_XDIE1,
  S_POSS_XDIE2,
  S_POSS_XDIE3,
  S_POSS_XDIE4,
  S_POSS_XDIE5,
  S_POSS_XDIE6,
  S_POSS_XDIE7,
  S_POSS_XDIE8,
  S_POSS_XDIE9,
  S_POSS_RAISE1,
  S_POSS_RAISE2,
  S_POSS_RAISE3,
  S_POSS_RAISE4,
  S_SPOS_STND,
  S_SPOS_STND2,
  S_SPOS_RUN1,
  S_SPOS_RUN2,
  S_SPOS_RUN3,
  S_SPOS_RUN4,
  S_SPOS_RUN5,
  S_SPOS_RUN6,
  S_SPOS_RUN7,
  S_SPOS_RUN8,
  S_SPOS_ATK1,
  S_SPOS_ATK2,
  S_SPOS_ATK3,
  S_SPOS_PAIN,
  S_SPOS_PAIN2,
  S_SPOS_DIE1,
  S_SPOS_DIE2,
  S_SPOS_DIE3,
  S_SPOS_DIE4,
  S_SPOS_DIE5,
  S_SPOS_XDIE1,
  S_SPOS_XDIE2,
  S_SPOS_XDIE3,
  S_SPOS_XDIE4,
  S_SPOS_XDIE5,
  S_SPOS_XDIE6,
  S_SPOS_XDIE7,
  S_SPOS_XDIE8,
  S_SPOS_XDIE9,
  S_SPOS_RAISE1,
  S_SPOS_RAISE2,
  S_SPOS_RAISE3,
  S_SPOS_RAISE4,
  S_SPOS_RAISE5,
  S_VILE_STND,
  S_VILE_STND2,
  S_VILE_RUN1,
  S_VILE_RUN2,
  S_VILE_RUN3,
  S_VILE_RUN4,
  S_VILE_RUN5,
  S_VILE_RUN6,
  S_VILE_RUN7,
  S_VILE_RUN8,
  S_VILE_RUN9,
  S_VILE_RUN10,
  S_VILE_RUN11,
  S_VILE_RUN12,
  S_VILE_ATK1,
  S_VILE_ATK2,
  S_VILE_ATK3,
  S_VILE_ATK4,
  S_VILE_ATK5,
  S_VILE_ATK6,
  S_VILE_ATK7,
  S_VILE_ATK8,
  S_VILE_ATK9,
  S_VILE_ATK10,
  S_VILE_ATK11,
  S_VILE_HEAL1,
  S_VILE_HEAL2,
  S_VILE_HEAL3,
  S_VILE_PAIN,
  S_VILE_PAIN2,
  S_VILE_DIE1,
  S_VILE_DIE2,
  S_VILE_DIE3,
  S_VILE_DIE4,
  S_VILE_DIE5,
  S_VILE_DIE6,
  S_VILE_DIE7,
  S_VILE_DIE8,
  S_VILE_DIE9,
  S_VILE_DIE10,
  S_FIRE1,
  S_FIRE2,
  S_FIRE3,
  S_FIRE4,
  S_FIRE5,
  S_FIRE6,
  S_FIRE7,
  S_FIRE8,
  S_FIRE9,
  S_FIRE10,
  S_FIRE11,
  S_FIRE12,
  S_FIRE13,
  S_FIRE14,
  S_FIRE15,
  S_FIRE16,
  S_FIRE17,
  S_FIRE18,
  S_FIRE19,
  S_FIRE20,
  S_FIRE21,
  S_FIRE22,
  S_FIRE23,
  S_FIRE24,
  S_FIRE25,
  S_FIRE26,
  S_FIRE27,
  S_FIRE28,
  S_FIRE29,
  S_FIRE30,
  S_SMOKE1,
  S_SMOKE2,
  S_SMOKE3,
  S_SMOKE4,
  S_SMOKE5,
  S_TRACER,
  S_TRACER2,
  S_TRACEEXP1,
  S_TRACEEXP2,
  S_TRACEEXP3,
  S_SKEL_STND,
  S_SKEL_STND2,
  S_SKEL_RUN1,
  S_SKEL_RUN2,
  S_SKEL_RUN3,
  S_SKEL_RUN4,
  S_SKEL_RUN5,
  S_SKEL_RUN6,
  S_SKEL_RUN7,
  S_SKEL_RUN8,
  S_SKEL_RUN9,
  S_SKEL_RUN10,
  S_SKEL_RUN11,
  S_SKEL_RUN12,
  S_SKEL_FIST1,
  S_SKEL_FIST2,
  S_SKEL_FIST3,
  S_SKEL_FIST4,
  S_SKEL_MISS1,
  S_SKEL_MISS2,
  S_SKEL_MISS3,
  S_SKEL_MISS4,
  S_SKEL_PAIN,
  S_SKEL_PAIN2,
  S_SKEL_DIE1,
  S_SKEL_DIE2,
  S_SKEL_DIE3,
  S_SKEL_DIE4,
  S_SKEL_DIE5,
  S_SKEL_DIE6,
  S_SKEL_RAISE1,
  S_SKEL_RAISE2,
  S_SKEL_RAISE3,
  S_SKEL_RAISE4,
  S_SKEL_RAISE5,
  S_SKEL_RAISE6,
  S_FATSHOT1,
  S_FATSHOT2,
  S_FATSHOTX1,
  S_FATSHOTX2,
  S_FATSHOTX3,
  S_FATT_STND,
  S_FATT_STND2,
  S_FATT_RUN1,
  S_FATT_RUN2,
  S_FATT_RUN3,
  S_FATT_RUN4,
  S_FATT_RUN5,
  S_FATT_RUN6,
  S_FATT_RUN7,
  S_FATT_RUN8,
  S_FATT_RUN9,
  S_FATT_RUN10,
  S_FATT_RUN11,
  S_FATT_RUN12,
  S_FATT_ATK1,
  S_FATT_ATK2,
  S_FATT_ATK3,
  S_FATT_ATK4,
  S_FATT_ATK5,
  S_FATT_ATK6,
  S_FATT_ATK7,
  S_FATT_ATK8,
  S_FATT_ATK9,
  S_FATT_ATK10,
  S_FATT_PAIN,
  S_FATT_PAIN2,
  S_FATT_DIE1,
  S_FATT_DIE2,
  S_FATT_DIE3,
  S_FATT_DIE4,
  S_FATT_DIE5,
  S_FATT_DIE6,
  S_FATT_DIE7,
  S_FATT_DIE8,
  S_FATT_DIE9,
  S_FATT_DIE10,
  S_FATT_RAISE1,
  S_FATT_RAISE2,
  S_FATT_RAISE3,
  S_FATT_RAISE4,
  S_FATT_RAISE5,
  S_FATT_RAISE6,
  S_FATT_RAISE7,
  S_FATT_RAISE8,
  S_CPOS_STND,
  S_CPOS_STND2,
  S_CPOS_RUN1,
  S_CPOS_RUN2,
  S_CPOS_RUN3,
  S_CPOS_RUN4,
  S_CPOS_RUN5,
  S_CPOS_RUN6,
  S_CPOS_RUN7,
  S_CPOS_RUN8,
  S_CPOS_ATK1,
  S_CPOS_ATK2,
  S_CPOS_ATK3,
  S_CPOS_ATK4,
  S_CPOS_PAIN,
  S_CPOS_PAIN2,
  S_CPOS_DIE1,
  S_CPOS_DIE2,
  S_CPOS_DIE3,
  S_CPOS_DIE4,
  S_CPOS_DIE5,
  S_CPOS_DIE6,
  S_CPOS_DIE7,
  S_CPOS_XDIE1,
  S_CPOS_XDIE2,
  S_CPOS_XDIE3,
  S_CPOS_XDIE4,
  S_CPOS_XDIE5,
  S_CPOS_XDIE6,
  S_CPOS_RAISE1,
  S_CPOS_RAISE2,
  S_CPOS_RAISE3,
  S_CPOS_RAISE4,
  S_CPOS_RAISE5,
  S_CPOS_RAISE6,
  S_CPOS_RAISE7,
  S_TROO_STND,
  S_TROO_STND2,
  S_TROO_RUN1,
  S_TROO_RUN2,
  S_TROO_RUN3,
  S_TROO_RUN4,
  S_TROO_RUN5,
  S_TROO_RUN6,
  S_TROO_RUN7,
  S_TROO_RUN8,
  S_TROO_ATK1,
  S_TROO_ATK2,
  S_TROO_ATK3,
  S_TROO_PAIN,
  S_TROO_PAIN2,
  S_TROO_DIE1,
  S_TROO_DIE2,
  S_TROO_DIE3,
  S_TROO_DIE4,
  S_TROO_DIE5,
  S_TROO_XDIE1,
  S_TROO_XDIE2,
  S_TROO_XDIE3,
  S_TROO_XDIE4,
  S_TROO_XDIE5,
  S_TROO_XDIE6,
  S_TROO_XDIE7,
  S_TROO_XDIE8,
  S_TROO_RAISE1,
  S_TROO_RAISE2,
  S_TROO_RAISE3,
  S_TROO_RAISE4,
  S_TROO_RAISE5,
  S_SARG_STND,
  S_SARG_STND2,
  S_SARG_RUN1,
  S_SARG_RUN2,
  S_SARG_RUN3,
  S_SARG_RUN4,
  S_SARG_RUN5,
  S_SARG_RUN6,
  S_SARG_RUN7,
  S_SARG_RUN8,
  S_SARG_ATK1,
  S_SARG_ATK2,
  S_SARG_ATK3,
  S_SARG_PAIN,
  S_SARG_PAIN2,
  S_SARG_DIE1,
  S_SARG_DIE2,
  S_SARG_DIE3,
  S_SARG_DIE4,
  S_SARG_DIE5,
  S_SARG_DIE6,
  S_SARG_RAISE1,
  S_SARG_RAISE2,
  S_SARG_RAISE3,
  S_SARG_RAISE4,
  S_SARG_RAISE5,
  S_SARG_RAISE6,
  S_HEAD_STND,
  S_HEAD_RUN1,
  S_HEAD_ATK1,
  S_HEAD_ATK2,
  S_HEAD_ATK3,
  S_HEAD_PAIN,
  S_HEAD_PAIN2,
  S_HEAD_PAIN3,
  S_HEAD_DIE1,
  S_HEAD_DIE2,
  S_HEAD_DIE3,
  S_HEAD_DIE4,
  S_HEAD_DIE5,
  S_HEAD_DIE6,
  S_HEAD_RAISE1,
  S_HEAD_RAISE2,
  S_HEAD_RAISE3,
  S_HEAD_RAISE4,
  S_HEAD_RAISE5,
  S_HEAD_RAISE6,
  S_BRBALL1,
  S_BRBALL2,
  S_BRBALLX1,
  S_BRBALLX2,
  S_BRBALLX3,
  S_BOSS_STND,
  S_BOSS_STND2,
  S_BOSS_RUN1,
  S_BOSS_RUN2,
  S_BOSS_RUN3,
  S_BOSS_RUN4,
  S_BOSS_RUN5,
  S_BOSS_RUN6,
  S_BOSS_RUN7,
  S_BOSS_RUN8,
  S_BOSS_ATK1,
  S_BOSS_ATK2,
  S_BOSS_ATK3,
  S_BOSS_PAIN,
  S_BOSS_PAIN2,
  S_BOSS_DIE1,
  S_BOSS_DIE2,
  S_BOSS_DIE3,
  S_BOSS_DIE4,
  S_BOSS_DIE5,
  S_BOSS_DIE6,
  S_BOSS_DIE7,
  S_BOSS_RAISE1,
  S_BOSS_RAISE2,
  S_BOSS_RAISE3,
  S_BOSS_RAISE4,
  S_BOSS_RAISE5,
  S_BOSS_RAISE6,
  S_BOSS_RAISE7,
  S_BOS2_STND,
  S_BOS2_STND2,
  S_BOS2_RUN1,
  S_BOS2_RUN2,
  S_BOS2_RUN3,
  S_BOS2_RUN4,
  S_BOS2_RUN5,
  S_BOS2_RUN6,
  S_BOS2_RUN7,
  S_BOS2_RUN8,
  S_BOS2_ATK1,
  S_BOS2_ATK2,
  S_BOS2_ATK3,
  S_BOS2_PAIN,
  S_BOS2_PAIN2,
  S_BOS2_DIE1,
  S_BOS2_DIE2,
  S_BOS2_DIE3,
  S_BOS2_DIE4,
  S_BOS2_DIE5,
  S_BOS2_DIE6,
  S_BOS2_DIE7,
  S_BOS2_RAISE1,
  S_BOS2_RAISE2,
  S_BOS2_RAISE3,
  S_BOS2_RAISE4,
  S_BOS2_RAISE5,
  S_BOS2_RAISE6,
  S_BOS2_RAISE7,
  S_SKULL_STND,
  S_SKULL_STND2,
  S_SKULL_RUN1,
  S_SKULL_RUN2,
  S_SKULL_ATK1,
  S_SKULL_ATK2,
  S_SKULL_ATK3,
  S_SKULL_ATK4,
  S_SKULL_PAIN,
  S_SKULL_PAIN2,
  S_SKULL_DIE1,
  S_SKULL_DIE2,
  S_SKULL_DIE3,
  S_SKULL_DIE4,
  S_SKULL_DIE5,
  S_SKULL_DIE6,
  S_SPID_STND,
  S_SPID_STND2,
  S_SPID_RUN1,
  S_SPID_RUN2,
  S_SPID_RUN3,
  S_SPID_RUN4,
  S_SPID_RUN5,
  S_SPID_RUN6,
  S_SPID_RUN7,
  S_SPID_RUN8,
  S_SPID_RUN9,
  S_SPID_RUN10,
  S_SPID_RUN11,
  S_SPID_RUN12,
  S_SPID_ATK1,
  S_SPID_ATK2,
  S_SPID_ATK3,
  S_SPID_ATK4,
  S_SPID_PAIN,
  S_SPID_PAIN2,
  S_SPID_DIE1,
  S_SPID_DIE2,
  S_SPID_DIE3,
  S_SPID_DIE4,
  S_SPID_DIE5,
  S_SPID_DIE6,
  S_SPID_DIE7,
  S_SPID_DIE8,
  S_SPID_DIE9,
  S_SPID_DIE10,
  S_SPID_DIE11,
  S_BSPI_STND,
  S_BSPI_STND2,
  S_BSPI_SIGHT,
  S_BSPI_RUN1,
  S_BSPI_RUN2,
  S_BSPI_RUN3,
  S_BSPI_RUN4,
  S_BSPI_RUN5,
  S_BSPI_RUN6,
  S_BSPI_RUN7,
  S_BSPI_RUN8,
  S_BSPI_RUN9,
  S_BSPI_RUN10,
  S_BSPI_RUN11,
  S_BSPI_RUN12,
  S_BSPI_ATK1,
  S_BSPI_ATK2,
  S_BSPI_ATK3,
  S_BSPI_ATK4,
  S_BSPI_PAIN,
  S_BSPI_PAIN2,
  S_BSPI_DIE1,
  S_BSPI_DIE2,
  S_BSPI_DIE3,
  S_BSPI_DIE4,
  S_BSPI_DIE5,
  S_BSPI_DIE6,
  S_BSPI_DIE7,
  S_BSPI_RAISE1,
  S_BSPI_RAISE2,
  S_BSPI_RAISE3,
  S_BSPI_RAISE4,
  S_BSPI_RAISE5,
  S_BSPI_RAISE6,
  S_BSPI_RAISE7,
  S_ARACH_PLAZ,
  S_ARACH_PLAZ2,
  S_ARACH_PLEX,
  S_ARACH_PLEX2,
  S_ARACH_PLEX3,
  S_ARACH_PLEX4,
  S_ARACH_PLEX5,
  S_CYBER_STND,
  S_CYBER_STND2,
  S_CYBER_RUN1,
  S_CYBER_RUN2,
  S_CYBER_RUN3,
  S_CYBER_RUN4,
  S_CYBER_RUN5,
  S_CYBER_RUN6,
  S_CYBER_RUN7,
  S_CYBER_RUN8,
  S_CYBER_ATK1,
  S_CYBER_ATK2,
  S_CYBER_ATK3,
  S_CYBER_ATK4,
  S_CYBER_ATK5,
  S_CYBER_ATK6,
  S_CYBER_PAIN,
  S_CYBER_DIE1,
  S_CYBER_DIE2,
  S_CYBER_DIE3,
  S_CYBER_DIE4,
  S_CYBER_DIE5,
  S_CYBER_DIE6,
  S_CYBER_DIE7,
  S_CYBER_DIE8,
  S_CYBER_DIE9,
  S_CYBER_DIE10,
  S_PAIN_STND,
  S_PAIN_RUN1,
  S_PAIN_RUN2,
  S_PAIN_RUN3,
  S_PAIN_RUN4,
  S_PAIN_RUN5,
  S_PAIN_RUN6,
  S_PAIN_ATK1,
  S_PAIN_ATK2,
  S_PAIN_ATK3,
  S_PAIN_ATK4,
  S_PAIN_PAIN,
  S_PAIN_PAIN2,
  S_PAIN_DIE1,
  S_PAIN_DIE2,
  S_PAIN_DIE3,
  S_PAIN_DIE4,
  S_PAIN_DIE5,
  S_PAIN_DIE6,
  S_PAIN_RAISE1,
  S_PAIN_RAISE2,
  S_PAIN_RAISE3,
  S_PAIN_RAISE4,
  S_PAIN_RAISE5,
  S_PAIN_RAISE6,
  S_SSWV_STND,
  S_SSWV_STND2,
  S_SSWV_RUN1,
  S_SSWV_RUN2,
  S_SSWV_RUN3,
  S_SSWV_RUN4,
  S_SSWV_RUN5,
  S_SSWV_RUN6,
  S_SSWV_RUN7,
  S_SSWV_RUN8,
  S_SSWV_ATK1,
  S_SSWV_ATK2,
  S_SSWV_ATK3,
  S_SSWV_ATK4,
  S_SSWV_ATK5,
  S_SSWV_ATK6,
  S_SSWV_PAIN,
  S_SSWV_PAIN2,
  S_SSWV_DIE1,
  S_SSWV_DIE2,
  S_SSWV_DIE3,
  S_SSWV_DIE4,
  S_SSWV_DIE5,
  S_SSWV_XDIE1,
  S_SSWV_XDIE2,
  S_SSWV_XDIE3,
  S_SSWV_XDIE4,
  S_SSWV_XDIE5,
  S_SSWV_XDIE6,
  S_SSWV_XDIE7,
  S_SSWV_XDIE8,
  S_SSWV_XDIE9,
  S_SSWV_RAISE1,
  S_SSWV_RAISE2,
  S_SSWV_RAISE3,
  S_SSWV_RAISE4,
  S_SSWV_RAISE5,
  S_KEENSTND,
  S_COMMKEEN,
  S_COMMKEEN2,
  S_COMMKEEN3,
  S_COMMKEEN4,
  S_COMMKEEN5,
  S_COMMKEEN6,
  S_COMMKEEN7,
  S_COMMKEEN8,
  S_COMMKEEN9,
  S_COMMKEEN10,
  S_COMMKEEN11,
  S_COMMKEEN12,
  S_KEENPAIN,
  S_KEENPAIN2,
  S_BRAIN,
  S_BRAIN_PAIN,
  S_BRAIN_DIE1,
  S_BRAIN_DIE2,
  S_BRAIN_DIE3,
  S_BRAIN_DIE4,
  S_BRAINEYE,
  S_BRAINEYESEE,
  S_BRAINEYE1,
  S_SPAWN1,
  S_SPAWN2,
  S_SPAWN3,
  S_SPAWN4,
  S_SPAWNFIRE1,
  S_SPAWNFIRE2,
  S_SPAWNFIRE3,
  S_SPAWNFIRE4,
  S_SPAWNFIRE5,
  S_SPAWNFIRE6,
  S_SPAWNFIRE7,
  S_SPAWNFIRE8,
  S_BRAINEXPLODE1,
  S_BRAINEXPLODE2,
  S_BRAINEXPLODE3,
  S_ARM1,
  S_ARM1A,
  S_ARM2,
  S_ARM2A,
  S_BAR1,
  S_BAR2,
  S_BEXP,
  S_BEXP2,
  S_BEXP3,
  S_BEXP4,
  S_BEXP5,
  S_BBAR1,
  S_BBAR2,
  S_BBAR3,
  S_BON1,
  S_BON1A,
  S_BON1B,
  S_BON1C,
  S_BON1D,
  S_BON1E,
  S_BON2,
  S_BON2A,
  S_BON2B,
  S_BON2C,
  S_BON2D,
  S_BON2E,
  S_BKEY,
  S_BKEY2,
  S_RKEY,
  S_RKEY2,
  S_YKEY,
  S_YKEY2,
  S_BSKULL,
  S_BSKULL2,
  S_RSKULL,
  S_RSKULL2,
  S_YSKULL,
  S_YSKULL2,
  S_STIM,
  S_MEDI,
  S_SOUL,
  S_SOUL2,
  S_SOUL3,
  S_SOUL4,
  S_SOUL5,
  S_SOUL6,
  S_PINV,
  S_PINV2,
  S_PINV3,
  S_PINV4,
  S_PSTR,
  S_PINS,
  S_PINS2,
  S_PINS3,
  S_PINS4,
  S_MEGA,
  S_MEGA2,
  S_MEGA3,
  S_MEGA4,
  S_SUIT,
  S_PMAP,
  S_PMAP2,
  S_PMAP3,
  S_PMAP4,
  S_PMAP5,
  S_PMAP6,
  S_PVIS,
  S_PVIS2,
  S_CLIP,
  S_AMMO,
  S_ROCK,
  S_BROK,
  S_CELL,
  S_CELP,
  S_SHEL,
  S_SBOX,
  S_BPAK,
  S_BFUG,
  S_MGUN,
  S_CSAW,
  S_LAUN,
  S_PLAS,
  S_SHOT,
  S_SHOT2,
  S_COLU,
  S_STALAG,
  S_BLOODYTWITCH,
  S_BLOODYTWITCH2,
  S_BLOODYTWITCH3,
  S_BLOODYTWITCH4,
  S_DEADTORSO,
  S_DEADBOTTOM,
  S_HEADSONSTICK,
  S_GIBS,
  S_HEADONASTICK,
  S_HEADCANDLES,
  S_HEADCANDLES2,
  S_DEADSTICK,
  S_LIVESTICK,
  S_LIVESTICK2,
  S_MEAT2,
  S_MEAT3,
  S_MEAT4,
  S_MEAT5,
  S_STALAGTITE,
  S_TALLGRNCOL,
  S_SHRTGRNCOL,
  S_TALLREDCOL,
  S_SHRTREDCOL,
  S_CANDLESTIK,
  S_CANDELABRA,
  S_SKULLCOL,
  S_TORCHTREE,
  S_BIGTREE,
  S_TECHPILLAR,
  S_EVILEYE,
  S_EVILEYE2,
  S_EVILEYE3,
  S_EVILEYE4,
  S_FLOATSKULL,
  S_FLOATSKULL2,
  S_FLOATSKULL3,
  S_HEARTCOL,
  S_HEARTCOL2,
  S_BLUETORCH,
  S_BLUETORCH2,
  S_BLUETORCH3,
  S_BLUETORCH4,
  S_GREENTORCH,
  S_GREENTORCH2,
  S_GREENTORCH3,
  S_GREENTORCH4,
  S_REDTORCH,
  S_REDTORCH2,
  S_REDTORCH3,
  S_REDTORCH4,
  S_BTORCHSHRT,
  S_BTORCHSHRT2,
  S_BTORCHSHRT3,
  S_BTORCHSHRT4,
  S_GTORCHSHRT,
  S_GTORCHSHRT2,
  S_GTORCHSHRT3,
  S_GTORCHSHRT4,
  S_RTORCHSHRT,
  S_RTORCHSHRT2,
  S_RTORCHSHRT3,
  S_RTORCHSHRT4,
  S_HANGNOGUTS,
  S_HANGBNOBRAIN,
  S_HANGTLOOKDN,
  S_HANGTSKULL,
  S_HANGTLOOKUP,
  S_HANGTNOBRAIN,
  S_COLONGIBS,
  S_SMALLPOOL,
  S_BRAINSTEM,
  S_TECHLAMP,
  S_TECHLAMP2,
  S_TECHLAMP3,
  S_TECHLAMP4,
  S_TECH2LAMP,
  S_TECH2LAMP2,
  S_TECH2LAMP3,
  S_TECH2LAMP4,
  S_TNT1,  

  NUMSTATES   

} statenum_t;

 
 
 
typedef struct
{
  spritenum_t sprite;        
  long        frame;         
  long        tics;          
   
  actionf_t   action;        
  statenum_t  nextstate;     
  long        misc1, misc2;  
} state_t;

 
extern state_t  states[NUMSTATES];
extern char *sprnames[];              

 
 
 
 
 
typedef enum {
  MT_PLAYER,
  MT_POSSESSED,
  MT_SHOTGUY,
  MT_VILE,
  MT_FIRE,
  MT_UNDEAD,
  MT_TRACER,
  MT_SMOKE,
  MT_FATSO,
  MT_FATSHOT,
  MT_CHAINGUY,
  MT_TROOP,
  MT_SERGEANT,
  MT_SHADOWS,
  MT_HEAD,
  MT_BRUISER,
  MT_BRUISERSHOT,
  MT_KNIGHT,
  MT_SKULL,
  MT_SPIDER,
  MT_BABY,
  MT_CYBORG,
  MT_PAIN,
  MT_WOLFSS,
  MT_KEEN,
  MT_BOSSBRAIN,
  MT_BOSSSPIT,
  MT_BOSSTARGET,
  MT_SPAWNSHOT,
  MT_SPAWNFIRE,
  MT_BARREL,
  MT_TROOPSHOT,
  MT_HEADSHOT,
  MT_ROCKET,
  MT_PLASMA,
  MT_BFG,
  MT_ARACHPLAZ,
  MT_PUFF,
  MT_BLOOD,
  MT_TFOG,
  MT_IFOG,
  MT_TELEPORTMAN,
  MT_EXTRABFG,
  MT_MISC0,
  MT_MISC1,
  MT_MISC2,
  MT_MISC3,
  MT_MISC4,
  MT_MISC5,
  MT_MISC6,
  MT_MISC7,
  MT_MISC8,
  MT_MISC9,
  MT_MISC10,
  MT_MISC11,
  MT_MISC12,
  MT_INV,
  MT_MISC13,
  MT_INS,
  MT_MISC14,
  MT_MISC15,
  MT_MISC16,
  MT_MEGA,
  MT_CLIP,
  MT_MISC17,
  MT_MISC18,
  MT_MISC19,
  MT_MISC20,
  MT_MISC21,
  MT_MISC22,
  MT_MISC23,
  MT_MISC24,
  MT_MISC25,
  MT_CHAINGUN,
  MT_MISC26,
  MT_MISC27,
  MT_MISC28,
  MT_SHOTGUN,
  MT_SUPERSHOTGUN,
  MT_MISC29,
  MT_MISC30,
  MT_MISC31,
  MT_MISC32,
  MT_MISC33,
  MT_MISC34,
  MT_MISC35,
  MT_MISC36,
  MT_MISC37,
  MT_MISC38,
  MT_MISC39,
  MT_MISC40,
  MT_MISC41,
  MT_MISC42,
  MT_MISC43,
  MT_MISC44,
  MT_MISC45,
  MT_MISC46,
  MT_MISC47,
  MT_MISC48,
  MT_MISC49,
  MT_MISC50,
  MT_MISC51,
  MT_MISC52,
  MT_MISC53,
  MT_MISC54,
  MT_MISC55,
  MT_MISC56,
  MT_MISC57,
  MT_MISC58,
  MT_MISC59,
  MT_MISC60,
  MT_MISC61,
  MT_MISC62,
  MT_MISC63,
  MT_MISC64,
  MT_MISC65,
  MT_MISC66,
  MT_MISC67,
  MT_MISC68,
  MT_MISC69,
  MT_MISC70,
  MT_MISC71,
  MT_MISC72,
  MT_MISC73,
  MT_MISC74,
  MT_MISC75,
  MT_MISC76,
  MT_MISC77,
  MT_MISC78,
  MT_MISC79,
  MT_MISC80,
  MT_MISC81,
  MT_MISC82,
  MT_MISC83,
  MT_MISC84,
  MT_MISC85,
  MT_MISC86,
  MT_PUSH,     
  MT_PULL,     

  NUMMOBJTYPES   

} mobjtype_t;

 
 
 
 
 
 

typedef struct
{
    int doomednum;     
                       
    int spawnstate;    
                       
    int spawnhealth;   
    int seestate;      
    int seesound;      
    int reactiontime;  
                       
                       
    int attacksound;   
    int painstate;     
    int painchance;    
                       
                       
                       
                       
                       
    int painsound;     
    int meleestate;    
    int missilestate;  
                       
    int deathstate;    
    int xdeathstate;   
                       
    int deathsound;    
                       
                       
    int speed;         
                       
    int radius;        
    int height;        
                       
    int mass;          
                       
                       
    int damage;        
    int activesound;   
                       
    int flags;         
    int raisestate;    
                       
                       
} mobjinfo_t;

 
extern mobjinfo_t mobjinfo[NUMMOBJTYPES];




 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
# 45 "p_pspr.h" 2






 
 
 
 




 
 
 
 
 

typedef enum
{
  ps_weapon,
  ps_flash,
  NUMPSPRITES
} psprnum_t;

typedef struct
{
  state_t *state;        
  int     tics;
  fixed_t sx;
  fixed_t sy;
} pspdef_t;

extern int weapon_preferences[2][NUMWEAPONS+1];       
int P_WeaponPreferred(int w1, int w2);

struct player_s;
int P_SwitchWeapon(struct player_s *player);
boolean P_CheckAmmo(struct player_s *player);
void P_SetupPsprites(struct player_s *curplayer);
void P_MovePsprites(struct player_s *curplayer);
void P_DropWeapon(struct player_s *player);



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
# 40 "d_player.h" 2


 
 
# 1 "p_mobj.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 




 



 


 
 


 
 
 






 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 
 
 
typedef enum
{
     
    MF_SPECIAL          = 1,
     
    MF_SOLID            = 2,
     
    MF_SHOOTABLE        = 4,
     
    MF_NOSECTOR         = 8,
     
    MF_NOBLOCKMAP       = 16,                    

     
    MF_AMBUSH           = 32,
     
    MF_JUSTHIT          = 64,
     
    MF_JUSTATTACKED     = 128,
     
     
    MF_SPAWNCEILING     = 256,
     
     
     
    MF_NOGRAVITY        = 512,

     
     
    MF_DROPOFF          = 0x400,
     
    MF_PICKUP           = 0x800,
     
    MF_NOCLIP           = 0x1000,
     
    MF_SLIDE            = 0x2000,
     
     
    MF_FLOAT            = 0x4000,
     
     
    MF_TELEPORT         = 0x8000,
     
     
    MF_MISSILE          = 0x10000,      
     
     
    MF_DROPPED          = 0x20000,
     
     
    MF_SHADOW           = 0x40000,
     
     
    MF_NOBLOOD          = 0x80000,
     
     
    MF_CORPSE           = 0x100000,
     
     
    MF_INFLOAT          = 0x200000,

     
     
     
    MF_COUNTKILL        = 0x400000,
    
     
     
    MF_COUNTITEM        = 0x800000,

     
     
    MF_SKULLFLY         = 0x1000000,

     
     
    MF_NOTDMATCH        = 0x2000000,

     
     
     
     
    MF_TRANSLATION      = 0xc000000,
     
    MF_TRANSSHIFT       = 26,

     
    MF_TRANSLUCENT      = 0x80000000                                 

} mobjflag_t;


 
 
 
 
 
 
 
 
 
 
 
 

typedef struct mobj_s
{
     
    thinker_t           thinker;

     
    fixed_t             x;
    fixed_t             y;
    fixed_t             z;

     
    struct mobj_s*      snext;
    struct mobj_s*      sprev;

     
    angle_t             angle;   
    spritenum_t         sprite;  
    int                 frame;   

     
     
    struct mobj_s*      bnext;
    struct mobj_s*      bprev;
    
    struct subsector_s* subsector;

     
    fixed_t             floorz;
    fixed_t             ceilingz;

     
    fixed_t             radius;
    fixed_t             height; 

     
    fixed_t             momx;
    fixed_t             momy;
    fixed_t             momz;

     
    int                 validcount;

    mobjtype_t          type;
    mobjinfo_t*         info;    
    
    int                 tics;    
    state_t*            state;
    int                 flags;
    int                 health;

     
    int                 movedir;         
    int                 movecount;       

     
     
    struct mobj_s*      target;

     
     
    int                 reactiontime;   

     
     
    int                 threshold;

     
     
    struct player_s*    player;

     
    int                 lastlook;       

     
    mapthing_t          spawnpoint;     

     
    struct mobj_s*      tracer; 

     
    struct mobj_s*      lastenemy;

     
     
                                                                     
    struct mobj_s* above_thing;

     
     
                                                                     
    struct mobj_s* below_thing;                                      
                                                                     
     
    int friction;                                            
    int movefactor;

     
    struct msecnode_s* touching_sectorlist;                  

     

} mobj_t;

 










 





extern mapthing_t itemrespawnque[];
extern int itemrespawntime[];
extern int iquehead;
extern int iquetail;

void    P_RespawnSpecials(void);
mobj_t  *P_SpawnMobj(fixed_t x, fixed_t y, fixed_t z, mobjtype_t type);
void    P_RemoveMobj(mobj_t *th);
boolean P_SetMobjState(mobj_t *mobj, statenum_t state);
void    P_MobjThinker(mobj_t *mobj);
void    P_SpawnPuff(fixed_t x, fixed_t y, fixed_t z);
void    P_SpawnBlood(fixed_t x, fixed_t y, fixed_t z, int damage);
mobj_t  *P_SpawnMissile(mobj_t *source, mobj_t *dest, mobjtype_t type);
void    P_SpawnPlayerMissile(mobj_t *source, mobjtype_t type);
void    P_SpawnMapThing (mapthing_t*  mthing);



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
# 44 "d_player.h" 2


 
 
 







 
 
 
typedef enum
{
   
  PST_LIVE,
   
  PST_DEAD,
   
  PST_REBORN            

} playerstate_t;


 
 
 
typedef enum
{
   
  CF_NOCLIP           = 1,
   
  CF_GODMODE          = 2,
   
  CF_NOMOMENTUM       = 4

} cheat_t;


 
 
 
typedef struct player_s
{
  mobj_t*             mo;
  playerstate_t       playerstate;
  ticcmd_t            cmd;

   
   
   
  fixed_t             viewz;
   
  fixed_t             viewheight;
   
  fixed_t             deltaviewheight;
   
  fixed_t             bob;    

   
   
  int                 health; 
  int                 armorpoints;
   
  int                 armortype;      

   
  int                 powers[NUMPOWERS];
  boolean             cards[NUMCARDS];
  boolean             backpack;
  
   
  int                 frags[4 ];
  weapontype_t        readyweapon;
  
   
  weapontype_t        pendingweapon;

  boolean             weaponowned[NUMWEAPONS];
  int                 ammo[NUMAMMO];
  int                 maxammo[NUMAMMO];

   
  int                 attackdown;
  int                 usedown;

   
   
  int                 cheats;         

   
  int                 refire;         

    
  int                 killcount;
  int                 itemcount;
  int                 secretcount;

   
  char*               message;        
  
   
  int                 damagecount;
  int                 bonuscount;

   
  mobj_t*             attacker;
  
   
  int                 extralight;

   
   
  int                 fixedcolormap;

   
   
  int                 colormap;       

   
  pspdef_t            psprites[NUMPSPRITES];

   
  boolean             didsecret;      

} player_t;


 
 
 
 
typedef struct
{
  boolean     in;      
    
   
  int         skills;
  int         sitems;
  int         ssecret;
  int         stime; 
  int         frags[4];
  int         score;   
  
} wbplayerstruct_t;

typedef struct
{
  int         epsd;    

   
  boolean     didsecret;
    
   
  int         last;
  int         next;   
    
  int         maxkills;
  int         maxitems;
  int         maxsecret;
  int         maxfrags;

   
  int         partime;
    
   
  int         pnum;   

  wbplayerstruct_t    plyr[4 ];

} wbstartstruct_t;




 
 
 
 
 
 
 
 
 
 
 
 
 
 
# 34 "d_net.h" 2








 
 
 
 
 
 
 



 



 


typedef enum
{
    CMD_SEND    = 1,
    CMD_GET     = 2

} command_t;


 
 
 
typedef struct
{
     
    unsigned            checksum;
     
    byte                retransmitfrom;
    
    byte                starttic;
    byte                player;
    byte                numtics;
    ticcmd_t            cmds[12 ];

} doomdata_t;


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 


typedef struct
{
  byte monsters_remember;
  byte variable_friction;
  byte weapon_recoil;
  byte allow_pushers;
  byte over_under;
  byte player_bobbing;
  byte fastparm;
  byte demo_insurance;
  unsigned long rngseed;
  char filler[sizeof(ticcmd_t)* 12 - 12 ];
} startup_t;


typedef struct
{
     
    long                id;
    
     
    short               intnum;         
     
     
    short               command;
     
    short               remotenode;
    
     
    short               datalength;

     
     
    short               numnodes;
     
    short               ticdup;
     
    short               extratics;
     
    short               deathmatch;
     
    short               savegame;
    short               episode;         
    short               map;             
    short               skill;           

     
    short               consoleplayer;
    short               numplayers;
    
     
     
     
     
     
     
    short               angleoffset;
     
    short               drone;          

     
    doomdata_t          data;
    
} doomcom_t;



 
void NetUpdate (void);

 
 
void D_QuitNetGame (void);

 
void TryRunTics (void);




 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
# 41 "doomstat.h" 2


 






 
 
 

extern  boolean nomonsters;  
extern  boolean respawnparm;   
extern  boolean fastparm;  
extern  boolean devparm;   

 
 
 

extern GameMode_t gamemode;
extern GameMission_t  gamemission;

 
extern  boolean modifiedgame;

 
extern int compatibility, default_compatibility;           

 
 

extern int demo_compatibility;      

 
extern int pitched_sounds, default_pitched_sounds;         

extern int     default_translucency;  
extern boolean general_translucency;  

extern int demo_insurance, default_demo_insurance;       

 
 
extern  Language_t   language;

 
 
 

 
extern  skill_t   startskill;
extern  int             startepisode;
extern  int   startmap;

extern  boolean   autostart;

 
extern  skill_t         gameskill;
extern  int   gameepisode;
extern  int   gamemap;

 
extern  boolean         respawnmonsters;

 
extern  boolean netgame;

 
 
extern  boolean deathmatch;

 
 
 
 
 

 
 
 
 
 
extern int snd_SfxVolume;       
extern int snd_MusicVolume;     

 
 
 
 
extern int snd_MusicDevice;
extern int snd_SfxDevice;
 
extern int snd_DesiredMusicDevice;
extern int snd_DesiredSfxDevice;


 
 
 

 
 
 
extern  boolean statusbaractive;

extern  boolean automapactive;  
extern  boolean menuactive;     
extern  boolean paused;         
extern  int     hud_active;     
extern  boolean viewactive;
extern  boolean nodrawers;
extern  boolean noblit;
extern  int     viewwindowx;
extern  int     viewwindowy;
extern  int     viewheight;
extern  int     viewwidth;
extern  int     scaledviewwidth;

 
 
extern  int viewangleoffset;

 
extern  int consoleplayer;
extern  int displayplayer;

 
 
 
 
extern  int totalkills;
extern  int totalitems;
extern  int totalsecret;

 
extern  int levelstarttic;   
extern  int leveltime;   

 
 

extern  boolean usergame;
extern  boolean demoplayback;
extern  boolean demorecording;

 
extern  boolean   singledemo;
 
extern  boolean   timingdemo;
 
extern  boolean   fastdemo;

extern  gamestate_t  gamestate;

 
 
 
 
 

extern  int   gametic;


 
extern  player_t  players[4 ];

 
extern  boolean    playeringame[];

extern  mapthing_t *deathmatchstarts;      
extern  size_t     num_deathmatchstarts;  

extern  mapthing_t *deathmatch_p;

 
extern  mapthing_t playerstarts[];

 
 
extern wbstartstruct_t wminfo;

 
 
extern int maxammo[];

 
 
 

 
extern  char    basedefault[];
extern  FILE   *debugfile;

 
extern  boolean precache;

 
 
extern  gamestate_t     wipegamestate;

extern  int             mouseSensitivity_horiz;  
extern  int             mouseSensitivity_vert;

 
extern  boolean         singletics;

extern  int             bodyqueslot;
extern  int             bodyquesize;                         
extern  mobj_t          **bodyque;                           

 
 

extern int    skyflatnum;

 
extern  doomcom_t  *doomcom;
extern  doomdata_t *netbuffer;   

extern  ticcmd_t   localcmds[];
extern  int        rndindex;

extern  int        maketic;
extern  int        nettics[];

extern  ticcmd_t   netcmds[][12 ];
extern  int        ticdup;

extern thinker_t thinkercap;   

 

 
extern int pitched_sounds, default_pitched_sounds;      

extern int allow_pushers;          
extern int default_allow_pushers;

extern int variable_friction;   
extern int default_variable_friction;

extern int monsters_remember;                           
extern int default_monsters_remember;

extern int weapon_recoil;           
extern int default_weapon_recoil;

extern int player_bobbing;   
extern int default_player_bobbing;   



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
# 41 "p_spec.c" 2

# 1 "p_spec.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 




# 1 "r_defs.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 




 
# 1 "c:/djgpp/include/math.h" 1 3
 













extern double __dj_huge_val;


double	acos(double _x);
double	asin(double _x);
double	atan(double _x);
double	atan2(double _y, double _x);
double	ceil(double _x);
double	cos(double _x);
double	cosh(double _x);
double	exp(double _x);
double	fabs(double _x);
double	floor(double _x);
double	fmod(double _x, double _y);
double	frexp(double _x, int *_pexp);
double	ldexp(double _x, int _exp);
double	log(double _y);
double	log10(double _x);
double	modf(double _x, double *_pint);
double	pow(double _x, double _y);
double	sin(double _x);
double	sinh(double _x);
double	sqrt(double _x);
double	tan(double _x);
double	tanh(double _x);
  




















double  acosh(double _a);
double  asinh(double _a);
double  atanh(double _a);
double	hypot(double _x, double _y);
double	log2(double _x);
long double modfl(long double _x, long double *_pint);
double	pow10(double _x);
double	pow2(double _x);

 
 

struct exception {
	int type;
	char *name;
	double arg1;
	double arg2;
	double retval;
};
extern double erf(double);
extern double erfc(double);
extern double gamma(double);
extern double hypot(double, double);
extern int isinf(double);
extern int isnan(double);
extern int finite(double);
extern double j0(double);
extern double j1(double);
extern double jn(int, double);
extern double lgamma(double);
extern double y0(double);
extern double y1(double);
extern double yn(int, double);
extern double acosh(double);
extern double asinh(double);
extern double atanh(double);
extern double cbrt(double);
extern double logb(double);
extern double nextafter(double, double);
extern double remainder(double, double);
extern double scalb(double, double);
extern int matherr(struct exception *);
extern double significand(double);
extern double copysign(double, double);
extern int ilogb(double);
extern double rint(double);
extern double scalbn(double, int);
extern double drem(double, double);
extern double expm1(double);
extern double log1p(double);




extern float acosf(float);
extern float asinf(float);
extern float atanf(float);
extern float atan2f(float, float);
extern float cosf(float);
extern float sinf(float);
extern float tanf(float);
extern float coshf(float);
extern float sinhf(float);
extern float tanhf(float);
extern float expf(float);
extern float frexpf(float, int *);
extern float ldexpf(float, int);
extern float logf(float);
extern float log10f(float);
extern float modff(float, float *);
extern float powf(float, float);
extern float sqrtf(float);
extern float ceilf(float);
extern float fabsf(float);
extern float floorf(float);
extern float fmodf(float, float);
extern float erff(float);
extern float erfcf(float);
extern float gammaf(float);
extern float hypotf(float, float);
extern int isinff(float);
extern int isnanf(float);
extern int finitef(float);
extern float j0f(float);
extern float j1f(float);
extern float jnf(int, float);
extern float lgammaf(float);
extern float y0f(float);
extern float y1f(float);
extern float ynf(int, float);
extern float acoshf(float);
extern float asinhf(float);
extern float atanhf(float);
extern float cbrtf(float);
extern float logbf(float);
extern float nextafterf(float, float);
extern float remainderf(float, float);
extern float scalbf(float, float);
extern float significandf(float);
extern float copysignf(float, float);
extern int ilogbf(float);
extern float rintf(float);
extern float scalbnf(float, int);
extern float dremf(float, float);
extern float expm1f(float);
extern float log1pf(float);



















# 34 "r_defs.h" 2


 


 
 


 
 


 






 
 







 
 
 
 

 
 
 
 
 
typedef struct
{
  fixed_t x, y;
} vertex_t;

 
typedef struct
{
  thinker_t thinker;   
  fixed_t x, y, z;
} degenmobj_t;

 
 
 
 

typedef struct
{
  fixed_t floorheight;
  fixed_t ceilingheight;
  short floorpic;
  short ceilingpic;
  short lightlevel;
  short special;
  short oldspecial;       
  short tag;
  int nexttag,firsttag;   
  int soundtraversed;     
  mobj_t *soundtarget;    
  int blockbox[4];        
  degenmobj_t soundorg;   
  int validcount;         
  mobj_t *thinglist;      

   
  void *floordata;     
  void *ceilingdata;   
  void *lightingdata;  

   
  int stairlock;    
  int prevsec;      
  int nextsec;      
  
   
  fixed_t   floor_xoffs,   floor_yoffs;
  fixed_t ceiling_xoffs, ceiling_yoffs;

   
  int heightsec;     

   
  int floorlightsec, ceilinglightsec;

  int bottommap, midmap, topmap;  

   
   
  struct msecnode_s *touching_thinglist;                

  int linecount;
  struct line_s **lines;

} sector_t;

 
 
 

typedef struct
{
  fixed_t textureoffset;  
  fixed_t rowoffset;      
  short toptexture;       
  short bottomtexture;
  short midtexture;
  sector_t* sector;       

   
   
   

  int special;

} side_t;

 
 
 
typedef enum
{
  ST_HORIZONTAL,
  ST_VERTICAL,
  ST_POSITIVE,
  ST_NEGATIVE
} slopetype_t;

typedef struct line_s
{
  vertex_t *v1, *v2;      
  fixed_t dx, dy;         
  short flags;            
  short special;         
  short tag;
  short sidenum[2];       
  fixed_t bbox[4];        
  slopetype_t slopetype;  
  sector_t *frontsector;  
  sector_t *backsector; 
  int validcount;         
  void *specialdata;      
  int tranlump;           
  int firsttag,nexttag;   
} line_t;

 
 
 
 
 
 
 

typedef struct subsector_s
{
  sector_t *sector;
  short numlines, firstline;
} subsector_t;

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

typedef struct msecnode_s
{
  sector_t          *m_sector;  
  struct mobj_s     *m_thing;   
  struct msecnode_s *m_tprev;   
  struct msecnode_s *m_tnext;   
  struct msecnode_s *m_sprev;   
  struct msecnode_s *m_snext;   
  boolean visited;  
} msecnode_t;

 
 
 
typedef struct
{
  vertex_t *v1, *v2;
  fixed_t offset;
  angle_t angle;
  side_t* sidedef;
  line_t* linedef;
  
   
   
   
   

  sector_t *frontsector, *backsector;
} seg_t;

 
 
 
typedef struct
{
  fixed_t  x,  y, dx, dy;         
  fixed_t bbox[2][4];             
  unsigned short children[2];     
} node_t;

 
typedef struct
{
  byte topdelta;  
  byte length;    
} post_t;

 
typedef post_t column_t;

 
 
 

 
 
 
 
 

typedef byte  lighttable_t; 

 
 
 

typedef struct drawseg_s
{
  seg_t *curline;
  int x1, x2;
  fixed_t scale1, scale2, scalestep;
  int silhouette;                        
  fixed_t bsilheight;                    
  fixed_t tsilheight;                    

   
   

  short *sprtopclip, *sprbottomclip, *maskedtexturecol;
} drawseg_t;

 
 
 
 
 
 
 

typedef struct 
{ 
  short width, height;   
  short leftoffset;      
  short topoffset;       
  int columnofs[8];      
} patch_t;

 
 
 
 

typedef struct vissprite_s
{
  int x1, x2;
  fixed_t gx, gy;               
  fixed_t gz, gzt;              
  fixed_t startfrac;            
  fixed_t scale;
  fixed_t xiscale;              
  fixed_t texturemid;
  int patch;
  int mobjflags;

   
  lighttable_t *colormap;
   
   
  int heightsec;

} vissprite_t;

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

typedef struct
{
   
   
   
  boolean rotate;

   
  short lump[8];

   
  byte  flip[8];

} spriteframe_t;

 
 
 
 

typedef struct
{
  int numframes;
  spriteframe_t *spriteframes;
} spritedef_t;

 
 
 
 
 

typedef struct visplane
{
  struct visplane *next;         
  int picnum, lightlevel, minx, maxx;
  fixed_t height;
  fixed_t xoffs, yoffs;          
  unsigned short pad1;           
  unsigned short top[320 ];
  unsigned short pad2, pad3;     
  unsigned short bottom[320 ];
  unsigned short pad4;
} visplane_t;



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
# 32 "p_spec.h" 2



 


 




 




 




 




 

 
 


 


 






 










 
 












 














                               
 















 











 













 









 











 











 

typedef enum
{
  WalkOnce,
  WalkMany,
  SwitchOnce,
  SwitchMany,
  GunOnce,
  GunMany,
  PushOnce,
  PushMany,
} triggertype_e;

 

typedef enum
{
  SpeedSlow,
  SpeedNormal,
  SpeedFast,
  SpeedTurbo,
} motionspeed_e;

 

typedef enum
{
  FtoHnF,
  FtoLnF,
  FtoNnF,
  FtoLnC,
  FtoC,
  FbyST,
  Fby24,
  Fby32,
} floortarget_e;

 

typedef enum
{
  FNoChg,
  FChgZero,
  FChgTxt,
  FChgTyp,
} floorchange_e;

 

typedef enum
{
  FTriggerModel,
  FNumericModel,
} floormodel_t;

 

typedef enum
{
  CtoHnC,
  CtoLnC,
  CtoNnC,
  CtoHnF,
  CtoF,
  CbyST,
  Cby24,
  Cby32,
} ceilingtarget_e;

 

typedef enum
{
  CNoChg,
  CChgZero,
  CChgTxt,
  CChgTyp,
} ceilingchange_e;

 

typedef enum
{
  CTriggerModel,
  CNumericModel,
} ceilingmodel_t;

 

typedef enum
{
  F2LnF,
  F2NnF,
  F2LnC,
  LnF2HnF,
} lifttarget_e;

 

typedef enum
{
  OdCDoor,
  ODoor,
  CdODoor,
  CDoor,
} doorkind_e;

 

typedef enum
{
  AnyKey,
  RCard,
  BCard,
  YCard,
  RSkull,
  BSkull,
  YSkull,
  AllKeys,
} keykind_e;

 
 
 
 
 

 

typedef enum
{
  floor_special,
  ceiling_special,
  lighting_special,
} special_e;

 
typedef enum
{
  trigChangeOnly,
  numChangeOnly,
} change_e;

 

typedef enum
{
  up,
  down,
  waiting,
  in_stasis
} plat_e;

typedef enum
{
  perpetualRaise,
  downWaitUpStay,
  raiseAndChange,
  raiseToNearestAndChange,
  blazeDWUS,
  genLift,       
  genPerpetual, 
  toggleUpDn,    

} plattype_e;

 

typedef enum
{
  normal,
  close30ThenOpen,
  close,
  open,
  raiseIn5Mins,
  blazeRaise,
  blazeOpen,
  blazeClose,

   
  genRaise,
  genBlazeRaise,
  genOpen,
  genBlazeOpen,
  genClose,
  genBlazeClose,
  genCdO,
  genBlazeCdO,
} vldoor_e;

 

typedef enum
{
  lowerToFloor,
  raiseToHighest,
  lowerToLowest,
  lowerToMaxFloor,
  lowerAndCrush,
  crushAndRaise,
  fastCrushAndRaise,
  silentCrushAndRaise,

   
  genCeiling,
  genCeilingChg,
  genCeilingChg0,
  genCeilingChgT,

   
  genCrusher,
  genSilentCrusher,

} ceiling_e;

 

typedef enum
{
   
  lowerFloor,
  
   
  lowerFloorToLowest,
  
   
  turboLower,
  
   
  raiseFloor,
  
   
  raiseFloorToNearest,

   
  lowerFloorToNearest,

   
  lowerFloor24,

   
  lowerFloor32Turbo,

   
  raiseToTexture,
  
   
   
  lowerAndChange,

  raiseFloor24,

   
  raiseFloor32Turbo,

  raiseFloor24AndChange,
  raiseFloorCrush,

   
  raiseFloorTurbo,       
  donutRaise,
  raiseFloor512,

   
  genFloor,
  genFloorChg,
  genFloorChg0,
  genFloorChgT,

   
  buildStair,
  genBuildStair,
} floor_e;

typedef enum
{
  build8,  
  turbo16  
    
} stair_e;

typedef enum
{
  elevateUp,
  elevateDown,
  elevateCurrent,
} elevator_e;

 
 
 
 
 

 
typedef enum
{
    top,
    middle,
    bottom

} bwhere_e;

 
typedef enum
{
  ok,
  crushed,
  pastdest
} result_e;

 
 
 
 
 

 

 

typedef struct
{
  char name1[9];
  char name2[9];
  short episode;
} __attribute__ ((packed)) switchlist_t;  

typedef struct
{
  line_t* line;
  bwhere_e where;
  int   btexture;
  int   btimer;
  mobj_t* soundorg;

} button_t;

 

typedef struct
{
  thinker_t thinker;
  sector_t* sector;
  int count;
  int maxlight;
  int minlight;
    
} fireflicker_t;

typedef struct
{
  thinker_t thinker;
  sector_t* sector;
  int count;
  int maxlight;
  int minlight;
  int maxtime;
  int mintime;
    
} lightflash_t;

typedef struct
{
  thinker_t thinker;
  sector_t* sector;
  int count;
  int minlight;
  int maxlight;
  int darktime;
  int brighttime;
    
} strobe_t;

typedef struct
{
  thinker_t thinker;
  sector_t* sector;
  int minlight;
  int maxlight;
  int direction;

} glow_t;

 

typedef struct
{
  thinker_t thinker;
  sector_t* sector;
  fixed_t speed;
  fixed_t low;
  fixed_t high;
  int wait;
  int count;
  plat_e status;
  plat_e oldstatus;
  boolean crush;
  int tag;
  plattype_e type;

  struct platlist *list;    
} plat_t;

 

typedef struct platlist {
  plat_t *plat; 
  struct platlist *next,**prev;
} platlist_t;

 

typedef struct
{
  thinker_t thinker;
  vldoor_e type;
  sector_t* sector;
  fixed_t topheight;
  fixed_t speed;

   
  int direction;
  
   
  int topwait;
   
   
  int topcountdown;
  
   
  line_t *line;
} vldoor_t;

 

typedef struct
{
  thinker_t thinker;
  ceiling_e type;
  sector_t* sector;
  fixed_t bottomheight;
  fixed_t topheight;
  fixed_t speed;
  fixed_t oldspeed;
  boolean crush;

   
  int newspecial;
  int oldspecial;  
  short texture;

   
  int direction;

   
  int tag;                   
  int olddirection;
  struct ceilinglist *list;    
} ceiling_t;

typedef struct ceilinglist {
  ceiling_t *ceiling; 
  struct ceilinglist *next,**prev;
} ceilinglist_t;

 

typedef struct
{
  thinker_t thinker;
  floor_e type;
  boolean crush;
  sector_t* sector;
  int direction;
  int newspecial;
  int oldspecial;    
  short texture;
  fixed_t floordestheight;
  fixed_t speed;

} floormove_t;

typedef struct
{
  thinker_t thinker;
  elevator_e type;
  sector_t* sector;
  int direction;
  fixed_t floordestheight;
  fixed_t ceilingdestheight;
  fixed_t speed;
} elevator_t;

 

 

typedef struct {
  thinker_t thinker;    
  fixed_t dx, dy;       
  int affectee;         
  int control;          
  fixed_t last_height;  
  fixed_t vdx, vdy;     
  int accel;            
  enum
  {
    sc_side,
    sc_floor,
    sc_ceiling,
    sc_carry,
    sc_carry_ceiling,   
  } type;               
} scroll_t;

 

typedef struct {
  thinker_t thinker;    
  int friction;         
  int movefactor;       
  int affectee;         
} friction_t;

 

typedef struct {
  thinker_t thinker;    
  enum
  {
    p_push,
    p_pull,
    p_wind,
    p_current,
  } type;
  mobj_t* source;       
  int x_mag;            
  int y_mag;            
  int magnitude;        
  int radius;           
  int x;                
  int y;                
  int affectee;         
} pusher_t;

 
 
 
 
 

 
 
 
extern  boolean levelTimer;
extern  int levelTimeCount;

 
extern button_t buttonlist[(4 *4) ];

extern platlist_t *activeplats;         

extern ceilinglist_t *activeceilings;   

 
 
 
 
 

int twoSided
( int sector,
  int line );

sector_t* getSector
( int currentSector,
  int line,
  int side );

side_t* getSide
( int   currentSector,
  int   line,
  int   side );

fixed_t P_FindLowestFloorSurrounding
( sector_t* sec );

fixed_t P_FindHighestFloorSurrounding
( sector_t* sec );

fixed_t P_FindNextHighestFloor
( sector_t* sec,
  int currentheight );

fixed_t P_FindNextLowestFloor
( sector_t* sec,
  int currentheight );

fixed_t P_FindLowestCeilingSurrounding
( sector_t* sec );  

fixed_t P_FindHighestCeilingSurrounding
( sector_t* sec );  

fixed_t P_FindNextLowestCeiling
( sector_t *sec,
  int currentheight );  

fixed_t P_FindNextHighestCeiling
( sector_t *sec,
  int currentheight );  

fixed_t P_FindShortestTextureAround
( int secnum );  

fixed_t P_FindShortestUpperAround
( int secnum );  

sector_t* P_FindModelFloorSector
( fixed_t floordestheight,
  int secnum );  

sector_t* P_FindModelCeilingSector
( fixed_t ceildestheight,
  int secnum );  

int P_FindSectorFromLineTag
( const line_t *line,
  int start );  

int P_FindLineFromLineTag
( const line_t *line,
  int start );    

int P_FindMinSurroundingLight
( sector_t* sector,
  int max );

sector_t* getNextSector
( line_t* line,
  sector_t* sec );

int P_CheckTag
(line_t *line);  

boolean P_CanUnlockGenDoor
( line_t* line,
  player_t* player);

int P_SectorActive
( special_e t,
  sector_t* s );

boolean P_IsSecret
( sector_t *sec );

boolean P_WasSecret
( sector_t *sec );

void P_ChangeSwitchTexture
( line_t* line,
  int useAgain );

 
 
 
 
 

 

void T_LightFlash
( lightflash_t* flash );

void T_StrobeFlash
( strobe_t* flash );

 
void T_FireFlicker
( fireflicker_t* flick );

void T_Glow
( glow_t* g );

 

void T_PlatRaise
( plat_t* plat );

 

void T_VerticalDoor
( vldoor_t* door );

 

void T_MoveCeiling
( ceiling_t* ceiling );

 

result_e T_MovePlane
( sector_t* sector,
  fixed_t speed,
  fixed_t dest,
  boolean crush,
  int floorOrCeiling,
  int direction );

void T_MoveFloor
( floormove_t* floor );

void T_MoveElevator
( elevator_t* elevator );

 

void T_Scroll
( scroll_t * );       

void T_Friction
( friction_t * );     

void T_Pusher
( pusher_t * );       

 
 
 
 
 

 

int EV_Teleport
( line_t* line,
  int side,
  mobj_t* thing );

 
int EV_SilentTeleport
( line_t* line,
  int side,
  mobj_t* thing );

 
int EV_SilentLineTeleport
( line_t* line,
  int side,
  mobj_t* thing,
  boolean reverse);

 

int
EV_DoElevator
( line_t* line,
  ceiling_e type );

int EV_BuildStairs
( line_t* line,
  stair_e type );

int EV_DoFloor
( line_t* line,
  floor_e floortype );

 

int EV_DoCeiling
( line_t* line,
  ceiling_e type );

int EV_CeilingCrushStop
( line_t* line );

 

int EV_VerticalDoor
( line_t* line,
  mobj_t* thing );

int EV_DoDoor
( line_t* line,
  vldoor_e type );

int EV_DoLockedDoor
( line_t* line,
  vldoor_e type,
  mobj_t* thing );

 

int EV_StartLightStrobing
( line_t* line );

int EV_TurnTagLightsOff
( line_t* line );

int EV_LightTurnOn
( line_t* line,
  int   bright );

 

int EV_DoChange
( line_t* line,
  change_e changetype );

int EV_DoDonut
( line_t* line );

 

int EV_DoPlat
( line_t* line,
  plattype_e  type,
  int amount );

int EV_StopPlat
( line_t* line );

 

int EV_DoGenFloor
( line_t* line );

int EV_DoGenCeiling
( line_t* line );

int EV_DoGenLift
( line_t* line );

int EV_DoGenStairs
( line_t* line );

int EV_DoGenCrusher
( line_t* line );

int EV_DoGenDoor
( line_t* line );

int EV_DoGenLockedDoor
( line_t* line );

 
 
 
 
 

 
void P_InitPicAnims
( void );

void P_InitSwitchList
( void );

 
void P_SpawnSpecials
( void );

 
void P_UpdateSpecials
( void );

 
boolean P_UseSpecialLine
( mobj_t* thing,
  line_t* line,
  int   side );

void P_ShootSpecialLine
( mobj_t* thing,
  line_t* line );

void P_CrossSpecialLine
( int linenum,
  int side,
  mobj_t* thing );

void P_PlayerInSpecialSector
( player_t* player );

 

void P_SpawnFireFlicker
( sector_t* sector );

void P_SpawnLightFlash
( sector_t* sector );

void P_SpawnStrobeFlash
( sector_t* sector,
  int fastOrSlow,
  int inSync );

void P_SpawnGlowingLight
( sector_t* sector );

 

void P_AddActivePlat
( plat_t* plat );

void P_RemoveActivePlat
( plat_t* plat );

void P_RemoveAllActivePlats
( void );     

void P_ActivateInStasis
( int tag );

 

void P_SpawnDoorCloseIn30
( sector_t* sec );

void P_SpawnDoorRaiseIn5Mins
( sector_t* sec,
  int secnum );

 

void P_RemoveActiveCeiling
( ceiling_t* ceiling );   

void P_RemoveAllActiveCeilings
( void );                 

void P_AddActiveCeiling
( ceiling_t* c );

void P_RemoveActiveCeiling
( ceiling_t* c );

int P_ActivateInStasisCeiling
( line_t* line ); 

mobj_t* P_GetPushThing(int);                                 



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
# 42 "p_spec.c" 2

# 1 "p_tick.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 










 
 

void P_Ticker(void);

extern thinker_t thinkercap;   

void P_InitThinkers(void);
void P_AddThinker(thinker_t *thinker);
void P_RemoveThinker(thinker_t *thinker);
void P_RemoveThinkerDelayed(thinker_t *thinker);     



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
# 43 "p_spec.c" 2

# 1 "p_setup.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 










void P_SetupLevel(int episode, int map, int playermask, skill_t skill);
void P_Init(void);                

extern byte     *rejectmatrix;    

 
extern long     *blockmaplump;    
extern long     *blockmap;
extern int      bmapwidth;
extern int      bmapheight;       
extern fixed_t  bmaporgx;
extern fixed_t  bmaporgy;         
extern mobj_t   **blocklinks;     



 
 
 
 
 
 
 
 
 
 
 
 
 
# 44 "p_spec.c" 2

# 1 "m_random.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 







 
 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

typedef enum {
  pr_skullfly,                 
  pr_damage,                   
  pr_crush,                    
  pr_genlift,                  
  pr_killtics,                 
  pr_damagemobj,               
  pr_painchance,               
  pr_lights,                   
  pr_explode,                  
  pr_respawn,                  
  pr_lastlook,                 
  pr_spawnthing,               
  pr_spawnpuff,                
  pr_spawnblood,               
  pr_missile,                  
  pr_shadow,                   
  pr_plats,                    
  pr_punch,                    
  pr_punchangle,               
  pr_saw,                      
  pr_plasma,                   
  pr_gunshot,                  
  pr_misfire,                  
  pr_shotgun,                  
  pr_bfg,                      
  pr_slimehurt,                
  pr_dmspawn,                  
  pr_missrange,                
  pr_trywalk,                  
  pr_newchase,                 
  pr_newchasedir,              
  pr_see,                      
  pr_facetarget,               
  pr_posattack,                
  pr_sposattack,               
  pr_cposattack,               
  pr_spidrefire,               
  pr_troopattack,              
  pr_sargattack,               
  pr_headattack,               
  pr_bruisattack,              
  pr_tracer,                   
  pr_skelfist,                 
  pr_scream,                   
  pr_brainscream,              
  pr_cposrefire,               
  pr_brainexp,                 
  pr_spawnfly,                 
  pr_misc,                     
  pr_all_in_one,               
   

   
  NUMPRCLASS                
} pr_class_t;

 
typedef struct {
  unsigned long seed[NUMPRCLASS];       
  int rndindex, prndindex;              
} rng_t;

extern rng_t rng;                       

extern unsigned long rngseed;           

 


 
int P_Random(pr_class_t);

 
void M_ClearRandom(void);



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
# 45 "p_spec.c" 2

# 1 "d_englsh.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 




 
 
 

 
 
 



 
 
 






































 
 
 










































 
 
 






 










 
 
 


 
 
 





















































  









  










  


  











  









  










  


  











  









  










  






















 
 











 
 
 










 
 
 






















 
 
 

# 398 "d_englsh.h"
  
  

# 418 "d_englsh.h"
  
  

# 438 "d_englsh.h"
  
  

# 457 "d_englsh.h"
  
  
 
  

# 474 "d_englsh.h"
  
 
  

# 495 "d_englsh.h"
  
  
 
  

# 509 "d_englsh.h"
  
  
 
  

# 529 "d_englsh.h"
  
  
  
 
  
  





  
  
 
  
  



  
  
 
  
  
# 565 "d_englsh.h"
  
  
 
  
  






  
  
 
  
  
# 591 "d_englsh.h"
  
 
  
  
# 607 "d_englsh.h"
  
 
  





  
 
  




  
  

# 637 "d_englsh.h"
  
  

# 649 "d_englsh.h"
  
  

# 660 "d_englsh.h"
  

# 673 "d_englsh.h"
  
  






  
  

# 694 "d_englsh.h"



 
 
 





















 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
# 46 "p_spec.c" 2

# 1 "m_argv.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 





 
 
 
extern int  myargc;
extern char **myargv;

 
int M_CheckParm(const char *check);



 
 
 
 
 
 
 
 
 
 
 
 
 
 
# 47 "p_spec.c" 2

# 1 "w_wad.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 









 
 
 

typedef struct
{
  char identification[4];                   
  int  numlumps;
  int  infotableofs;
} wadinfo_t;

typedef struct
{
  int  filepos;
  int  size;
  char name[8];
} filelump_t;

 
 
 

typedef struct
{
   

  char  name[8];
  int   size;
  const void *data;      

   
  int index, next;

   
  enum {
    ns_global=0,
    ns_sprites,
    ns_flats,
    ns_colormaps
  } namespace;

  int handle;
  int position;
   
  enum {
    source_iwad=0,  
    source_pwad,    
    source_lmp,     
    source_pre      
  } source;  
} lumpinfo_t;

 
extern const size_t num_predefined_lumps;
extern const lumpinfo_t predefined_lumps[];

extern void       **lumpcache;
extern lumpinfo_t *lumpinfo;
extern int        numlumps;

void W_InitMultipleFiles(char *const*filenames, int *const filesource);

 
 


int     (W_CheckNumForName)(const char* name, int);    
int     W_GetNumForName (const char* name);
int     W_LumpLength (int lump);
void    W_ReadLump (int lump, void *dest);
void*   W_CacheLumpNum (int lump, int tag);




char *AddDefaultExtension(char *, const char *);   
void ExtractFileBase(const char *, char *);        
unsigned W_LumpNameHash(const char *s);            

 
extern void WritePredefinedLumpWad(const char *filename);  



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
# 48 "p_spec.c" 2

# 1 "r_main.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 





# 1 "r_data.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 






# 1 "r_state.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 





 

# 1 "r_data.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 


# 70 "r_data.h"


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
# 36 "r_state.h" 2







 
 
 
 

 
extern fixed_t *textureheight;

 
extern fixed_t *spritewidth;

extern fixed_t *spriteoffset;
extern fixed_t *spritetopoffset;

extern lighttable_t **colormaps;           
extern lighttable_t *fullcolormap;         

extern int viewwidth;
extern int scaledviewwidth;
extern int viewheight;

extern int firstflat;

 
extern int *flattranslation;    
extern int *texturetranslation; 

 
extern int firstspritelump;
extern int lastspritelump;
extern int numspritelumps;

 
 
 
extern int              numsprites;
extern spritedef_t      *sprites;

extern int              numvertexes;
extern vertex_t         *vertexes;

extern int              numsegs;
extern seg_t            *segs;

extern int              numsectors;
extern sector_t         *sectors;

extern int              numsubsectors;
extern subsector_t      *subsectors;

extern int              numnodes;
extern node_t           *nodes;

extern int              numlines;
extern line_t           *lines;

extern int              numsides;
extern side_t           *sides;


 
 
 
extern fixed_t          viewx;
extern fixed_t          viewy;
extern fixed_t          viewz;
extern angle_t          viewangle;
extern player_t         *viewplayer;
extern angle_t          clipangle;
extern int              viewangletox[8192 /2];
extern angle_t          xtoviewangle[320 +1];   
extern fixed_t          rw_distance;
extern angle_t          rw_normalangle;

 
extern int              rw_angle1;

 
extern int              sscount;

extern visplane_t       *floorplane;
extern visplane_t       *ceilingplane;



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
# 36 "r_data.h" 2






 
byte*
R_GetColumn
( int           tex,
  int           col );


 
void R_InitData (void);
void R_PrecacheLevel (void);


 
 
 
int R_FlatNumForName (const char* name);    


 
 
int R_TextureNumForName (const char *name);     
int R_CheckTextureNumForName (const char *name); 

void R_InitTranMap(int);       
int R_ColormapNumForName(const char *name);       

extern byte *main_tranmap, *tranmap;



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
# 34 "r_main.h" 2






 
 
 

extern fixed_t  viewcos;
extern fixed_t  viewsin;
extern int      viewwidth;
extern int      viewheight;
extern int      viewwindowx;
extern int      viewwindowy;
extern int      centerx;
extern int      centery;
extern fixed_t  centerxfrac;
extern fixed_t  centeryfrac;
extern fixed_t  projection;
extern int      validcount;
extern int      linecount;
extern int      loopcount;

 
 
 
 
 

 








 
extern lighttable_t *(*scalelight)[48 ];
extern lighttable_t *(*zlight)[128 ];
extern lighttable_t *fullcolormap;
extern int numcolormaps;     
extern lighttable_t **colormaps;
 

extern int          extralight;
extern lighttable_t *fixedcolormap;

 
 



 
 
 

extern void (*colfunc)(void);

 
 
 

int R_PointOnSide(fixed_t x, fixed_t y, node_t *node);
int R_PointOnSegSide(fixed_t x, fixed_t y, seg_t *line);
angle_t R_PointToAngle(fixed_t x, fixed_t y);
angle_t R_PointToAngle2(fixed_t x1, fixed_t y1, fixed_t x2, fixed_t y2);
fixed_t R_ScaleFromGlobalAngle(angle_t visangle);
subsector_t *R_PointInSubsector(fixed_t x, fixed_t y);

 
 
 

void R_RenderPlayerView(player_t *player);    
void R_Init(void);                            
void R_SetViewSize(int blocks);               



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
# 49 "p_spec.c" 2

# 1 "p_maputl.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 






 










typedef struct {
  fixed_t     x;
  fixed_t     y;
  fixed_t     dx;
  fixed_t     dy;
} divline_t;

typedef struct {
  fixed_t     frac;            
  boolean     isaline;
  union {
    mobj_t* thing;
    line_t* line;
  } d;
} intercept_t;

typedef boolean (*traverser_t)(intercept_t *in);

fixed_t P_AproxDistance (fixed_t dx, fixed_t dy);
int     P_PointOnLineSide (fixed_t x, fixed_t y, line_t *line);
int     P_PointOnDivlineSide (fixed_t x, fixed_t y, divline_t *line);
void    P_MakeDivline (line_t *li, divline_t *dl);
fixed_t P_InterceptVector (divline_t *v2, divline_t *v1);
int     P_BoxOnLineSide (fixed_t *tmbox, line_t *ld);
void    P_LineOpening (line_t *linedef);
void    P_UnsetThingPosition(mobj_t *thing);
void    P_SetThingPosition(mobj_t *thing);
boolean P_BlockLinesIterator (int x, int y, boolean func(line_t *));
boolean P_BlockThingsIterator(int x, int y, boolean func(mobj_t *));
boolean ThingIsOnLine(mobj_t *t, line_t *l);   
boolean P_PathTraverse(fixed_t x1, fixed_t y1, fixed_t x2, fixed_t y2,
                       int flags, boolean trav(intercept_t *));

extern fixed_t opentop;
extern fixed_t openbottom;
extern fixed_t openrange;
extern fixed_t lowfloor;
extern divline_t trace;



 
 
 
 
 
 
 
 
# 50 "p_spec.c" 2

# 1 "p_map.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 











 
 


 
boolean P_TryMove(mobj_t *thing, fixed_t x, fixed_t y, boolean dropoff);

boolean P_TeleportMove(mobj_t *thing, fixed_t x, fixed_t y);
void    P_SlideMove(mobj_t *mo);
boolean P_CheckSight(mobj_t *t1, mobj_t *t2);
void    P_UseLines(player_t *player);
boolean P_ChangeSector(sector_t *sector, boolean crunch);
fixed_t P_AimLineAttack(mobj_t *t1, angle_t angle, fixed_t distance);
void    P_LineAttack(mobj_t *t1, angle_t angle, fixed_t distance,
                     fixed_t slope, int damage );
void    P_RadiusAttack(mobj_t *spot, mobj_t *source, int damage);
boolean P_CheckPosition(mobj_t *thing, fixed_t x, fixed_t y);

 
boolean P_CheckSector(sector_t *sector, boolean crunch);
void    P_DelSeclist(msecnode_t *);                          
void    P_CreateSecNodeList(mobj_t*,fixed_t,fixed_t);        
int     P_GetMoveFactor(mobj_t* mo);                         
boolean Check_Sides(mobj_t *, int, int);                     


 
extern boolean floatok;
extern fixed_t tmfloorz;
extern fixed_t tmceilingz;
extern line_t *ceilingline;
extern mobj_t *linetarget;      
extern msecnode_t *sector_list;                              
extern fixed_t tmbbox[4];          



 
 
 
 
 
 
 
 
 
 
 
# 51 "p_spec.c" 2

# 1 "g_game.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 





# 1 "d_event.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 









 
 
 

 
typedef enum
{
  ev_keydown,
  ev_keyup,
  ev_mouse,
  ev_joystick
} evtype_t;

 
typedef struct
{
  evtype_t  type;
  int       data1;     
  int       data2;     
  int       data3;     
} event_t;

 
typedef enum
{
  ga_nothing,
  ga_loadlevel,
  ga_newgame,
  ga_loadgame,
  ga_savegame,
  ga_playdemo,
  ga_completed,
  ga_victory,
  ga_worlddone,
  ga_screenshot
} gameaction_t;



 
 
 
typedef enum
{
   
  BT_ATTACK       = 1,

   
  BT_USE          = 2,

   
  BT_SPECIAL      = 128,
  BT_SPECIALMASK  = 3,
    
   
   
  BT_CHANGE       = 4,

   
 
  BT_WEAPONMASK   = (8+16+32+64),  
  BT_WEAPONSHIFT  = 3,

   
  BTS_PAUSE       = 1,

   
  BTS_SAVEGAME    = 2,

   
  BTS_SAVEMASK    = (4+8+16),
  BTS_SAVESHIFT   = 2,
  
} buttoncode_t;


 
 
 


extern event_t   events[64 ];
extern int       eventhead;
extern int       eventtail;

extern gameaction_t gameaction;



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
# 31 "g_game.h" 2



 
 
 

 


boolean G_Responder(event_t *ev);
boolean G_CheckDemoStatus(void);
boolean G_CheckDemoStatus(void);
void G_DeathMatchSpawnPlayer(int playernum);
void G_InitNew(skill_t skill, int episode, int map);
void G_DeferedInitNew(skill_t skill, int episode, int map);
void G_DeferedPlayDemo(char *demo);
void G_LoadGame(char *name, int slot, boolean is_command);  
void G_ForcedLoadGame(void);            
void G_DoLoadGame(void);
void G_SaveGame(int slot, char *description);  
void G_RecordDemo(char *name);               
void G_BeginRecording(void);
void G_PlayDemo(char *name);
void G_TimeDemo(char *name);
void G_ExitLevel(void);
void G_SecretExitLevel(void);
void G_WorldDone(void);
void G_Ticker(void);
void G_ScreenShot(void);
void G_ReloadDefaults(void);      
void G_SaveGameName(char *,int);  
void G_SetFastParms(int);         
void G_DoNewGame(void);
void G_DoReborn(int playernum);
void G_DoPlayDemo(void);
void G_DoCompleted(void);
void G_DoSaveGame(void);
void G_ReadDemoTiccmd(ticcmd_t *cmd);
void G_WriteDemoTiccmd(ticcmd_t *cmd);
void G_DoWorldDone(void);
byte *G_ReadOptions(byte *demo_p);          
byte *G_WriteOptions(byte *demo_p);         
void G_PlayerReborn(int player);
void G_InitNew(skill_t skill, int episode, int map);
void G_DoLoadLevel(void  );
void G_DoLoadGame(void);
void G_DoVictory(void);

 
void dprintf(const char *, ...) __attribute__((format(printf,1,2)));

 

extern int  key_right;
extern int  key_left;
extern int  key_up;
extern int  key_down;
extern int  key_menu_right;                                   
extern int  key_menu_left;                                    
extern int  key_menu_up;                                      
extern int  key_menu_down;
extern int  key_menu_backspace;                               
extern int  key_menu_escape;                                  
extern int  key_menu_enter;                                   
extern int  key_strafeleft;
extern int  key_straferight;

extern int  key_fire;
extern int  key_use;
extern int  key_strafe;
extern int  key_speed;
extern int  key_escape;                                              
extern int  key_savegame;                                            
extern int  key_loadgame;                                            
extern int  key_autorun;
extern int  key_reverse;
extern int  key_zoomin;
extern int  key_zoomout;
extern int  key_chat;
extern int  key_backspace;
extern int  key_enter;
extern int  key_help;
extern int  key_soundvolume;
extern int  key_hud;
extern int  key_quicksave;
extern int  key_endgame;
extern int  key_messages;
extern int  key_quickload;
extern int  key_quit;
extern int  key_gamma;
extern int  key_spy;
extern int  key_pause;
extern int  key_forward;
extern int  key_leftturn;
extern int  key_rightturn;
extern int  key_backward;
extern int  key_weapontoggle;
extern int  key_weapon1;
extern int  key_weapon2;
extern int  key_weapon3;
extern int  key_weapon4;
extern int  key_weapon5;
extern int  key_weapon6;
extern int  key_weapon7;
extern int  key_weapon8;
extern int  key_weapon9;                                            
extern int  destination_keys[4 ];
extern int  key_map_right;
extern int  key_map_left;
extern int  key_map_up;
extern int  key_map_down;
extern int  key_map_zoomin;
extern int  key_map_zoomout;
extern int  key_map;
extern int  key_map_gobig;
extern int  key_map_follow;
extern int  key_map_mark;                                            
extern int  key_map_clear;                                           
extern int  key_map_grid;                                            
extern int  key_screenshot;     
extern int  autorun;            

extern int  defaultskill;       
extern boolean haswolflevels;   

extern int  bodyquesize;        

 
 
extern int pars[4][10];   
extern int cpars[32];     



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
# 52 "p_spec.c" 2

# 1 "p_inter.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 











 


 


boolean P_GivePower(player_t *, int);
void P_TouchSpecialThing(mobj_t *special, mobj_t *toucher);
void P_DamageMobj(mobj_t *target,mobj_t *inflictor,mobj_t *source,int damage);

 

extern int god_health;    
extern int idfa_armor;
extern int idfa_armor_class;
extern int idkfa_armor;
extern int idkfa_armor_class;   
 
extern int initial_health;
extern int initial_bullets;
extern int maxhealth;
extern int max_armor;
extern int green_armor_class;
extern int blue_armor_class;
extern int max_soul;
extern int soul_health;
extern int mega_health;
extern int god_health;
extern int idfa_armor;
extern int idfa_armor_class;
extern int idkfa_armor;
extern int idkfa_armor_class;
extern int bfgcells;
extern int maxammo[], clipammo[];



 
 
 
 
 
 
 
 
 
 
 
 
 
 
# 53 "p_spec.c" 2

# 1 "s_sound.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 








 
 
 
 
 
void S_Init(int sfxVolume, int musicVolume);

 
 
 
 
 
void S_Start(void);

 
 
 
 
void S_StartSound(void *origin, int sound_id);

 
void S_StartSoundAtVolume(void *origin, int sound_id, int volume);

 


 
void S_StopSound(void* origin);

 
void S_StartMusic(int music_id);

 
void S_ChangeMusic(int music_id, int looping);

 
void S_StopMusic(void);

 
void S_PauseSound(void);
void S_ResumeSound(void);

 
 
 
void S_UpdateSounds(void* listener);
void S_SetMusicVolume(int volume);
void S_SetSfxVolume(int volume);

 
extern int numChannels;

 
extern int idmusnum;



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
# 54 "p_spec.c" 2

# 1 "sounds.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 




 
 
 

struct sfxinfo_struct;

typedef struct sfxinfo_struct sfxinfo_t;

struct sfxinfo_struct {

   
  char *name;

   
  int singularity;

   
  int priority;

   
  sfxinfo_t *link;

   
  int pitch;

   
  int volume;

   
  void *data;

   
   
   
  int usefulness;

   
  int lumpnum;
};

 
 
 

typedef struct {
   
  char *name;

   
  int lumpnum;

   
  void *data;

   
  int handle;
} musicinfo_t;

 
extern sfxinfo_t    S_sfx[];

 
extern musicinfo_t  S_music[];

 
 
 

typedef enum {
  mus_None,
  mus_e1m1,
  mus_e1m2,
  mus_e1m3,
  mus_e1m4,
  mus_e1m5,
  mus_e1m6,
  mus_e1m7,
  mus_e1m8,
  mus_e1m9,
  mus_e2m1,
  mus_e2m2,
  mus_e2m3,
  mus_e2m4,
  mus_e2m5,
  mus_e2m6,
  mus_e2m7,
  mus_e2m8,
  mus_e2m9,
  mus_e3m1,
  mus_e3m2,
  mus_e3m3,
  mus_e3m4,
  mus_e3m5,
  mus_e3m6,
  mus_e3m7,
  mus_e3m8,
  mus_e3m9,
  mus_inter,
  mus_intro,
  mus_bunny,
  mus_victor,
  mus_introa,
  mus_runnin,
  mus_stalks,
  mus_countd,
  mus_betwee,
  mus_doom,
  mus_the_da,
  mus_shawn,
  mus_ddtblu,
  mus_in_cit,
  mus_dead,
  mus_stlks2,
  mus_theda2,
  mus_doom2,
  mus_ddtbl2,
  mus_runni2,
  mus_dead2,
  mus_stlks3,
  mus_romero,
  mus_shawn2,
  mus_messag,
  mus_count2,
  mus_ddtbl3,
  mus_ampie,
  mus_theda3,
  mus_adrian,
  mus_messg2,
  mus_romer2,
  mus_tense,
  mus_shawn3,
  mus_openin,
  mus_evil,
  mus_ultima,
  mus_read_m,
  mus_dm2ttl,
  mus_dm2int,
  NUMMUSIC
} musicenum_t;

 
 
 

typedef enum {
  sfx_None,
  sfx_pistol,
  sfx_shotgn,
  sfx_sgcock,
  sfx_dshtgn,
  sfx_dbopn,
  sfx_dbcls,
  sfx_dbload,
  sfx_plasma,
  sfx_bfg,
  sfx_sawup,
  sfx_sawidl,
  sfx_sawful,
  sfx_sawhit,
  sfx_rlaunc,
  sfx_rxplod,
  sfx_firsht,
  sfx_firxpl,
  sfx_pstart,
  sfx_pstop,
  sfx_doropn,
  sfx_dorcls,
  sfx_stnmov,
  sfx_swtchn,
  sfx_swtchx,
  sfx_plpain,
  sfx_dmpain,
  sfx_popain,
  sfx_vipain,
  sfx_mnpain,
  sfx_pepain,
  sfx_slop,
  sfx_itemup,
  sfx_wpnup,
  sfx_oof,
  sfx_telept,
  sfx_posit1,
  sfx_posit2,
  sfx_posit3,
  sfx_bgsit1,
  sfx_bgsit2,
  sfx_sgtsit,
  sfx_cacsit,
  sfx_brssit,
  sfx_cybsit,
  sfx_spisit,
  sfx_bspsit,
  sfx_kntsit,
  sfx_vilsit,
  sfx_mansit,
  sfx_pesit,
  sfx_sklatk,
  sfx_sgtatk,
  sfx_skepch,
  sfx_vilatk,
  sfx_claw,
  sfx_skeswg,
  sfx_pldeth,
  sfx_pdiehi,
  sfx_podth1,
  sfx_podth2,
  sfx_podth3,
  sfx_bgdth1,
  sfx_bgdth2,
  sfx_sgtdth,
  sfx_cacdth,
  sfx_skldth,
  sfx_brsdth,
  sfx_cybdth,
  sfx_spidth,
  sfx_bspdth,
  sfx_vildth,
  sfx_kntdth,
  sfx_pedth,
  sfx_skedth,
  sfx_posact,
  sfx_bgact,
  sfx_dmact,
  sfx_bspact,
  sfx_bspwlk,
  sfx_vilact,
  sfx_noway,
  sfx_barexp,
  sfx_punch,
  sfx_hoof,
  sfx_metal,
  sfx_chgun,
  sfx_tink,
  sfx_bdopn,
  sfx_bdcls,
  sfx_itmbk,
  sfx_flame,
  sfx_flamst,
  sfx_getpow,
  sfx_bospit,
  sfx_boscub,
  sfx_bossit,
  sfx_bospn,
  sfx_bosdth,
  sfx_manatk,
  sfx_mandth,
  sfx_sssit,
  sfx_ssdth,
  sfx_keenpn,
  sfx_keendt,
  sfx_skeact,
  sfx_skesit,
  sfx_skeatk,
  sfx_radio,
  NUMSFX
} sfxenum_t;



 
 
 
 
 
 
 
 
 
 
 
 
 
# 55 "p_spec.c" 2

# 1 "m_bbox.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 










 
enum
{
  BOXTOP,
  BOXBOTTOM,
  BOXLEFT,
  BOXRIGHT
};   

 

void M_ClearBox(fixed_t* box);

void M_AddToBox(fixed_t* box,fixed_t x,fixed_t y);



 
 
 
 
 
 
 
 
 
 
 
 
 
 
# 56 "p_spec.c" 2

# 1 "d_deh.h" 1
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 




 
 
 
 
 
 
 
 
 
 

 
 
 
 
extern char *s_D_DEVSTR;  
 
extern char *s_D_CDROM;  

 
 
 
 
extern char *s_PRESSKEY;  
 
extern char *s_PRESSYN;  
 
extern char *s_QUITMSG;  
 
extern char *s_LOADNET;  
 
extern char *s_QLOADNET;  
 
extern char *s_QSAVESPOT;  
 
extern char *s_SAVEDEAD;  
 
extern char *s_QSPROMPT;  
 
extern char *s_QLPROMPT;  

 



extern char *s_NEWGAME;  

 



extern char *s_NIGHTMARE;  

 



extern char *s_SWSTRING;  

 
extern char *s_MSGOFF;  
 
extern char *s_MSGON;  
 
extern char *s_NETEND;  
 
extern char *s_ENDGAME;  

 
extern char *s_DOSY;  

 
extern char *s_DETAILHI;  
 
extern char *s_DETAILLO;  
 
extern char *s_GAMMALVL0;  
 
extern char *s_GAMMALVL1;  
 
extern char *s_GAMMALVL2;  
 
extern char *s_GAMMALVL3;  
 
extern char *s_GAMMALVL4;  
 
extern char *s_EMPTYSTRING;  

 
 
 
 
extern char *s_GOTARMOR;  
 
extern char *s_GOTMEGA;  
 
extern char *s_GOTHTHBONUS;  
 
extern char *s_GOTARMBONUS;  
 
extern char *s_GOTSTIM;  
 
extern char *s_GOTMEDINEED;  
 
extern char *s_GOTMEDIKIT;  
 
extern char *s_GOTSUPER;  

 
extern char *s_GOTBLUECARD;  
 
extern char *s_GOTYELWCARD;  
 
extern char *s_GOTREDCARD;  
 
extern char *s_GOTBLUESKUL;  
 
extern char *s_GOTYELWSKUL;  
 
extern char *s_GOTREDSKULL;  

 
extern char *s_GOTINVUL;  
 
extern char *s_GOTBERSERK;  
 
extern char *s_GOTINVIS;  
 
extern char *s_GOTSUIT;  
 
extern char *s_GOTMAP;  
 
extern char *s_GOTVISOR;  
 
extern char *s_GOTMSPHERE;  

 
extern char *s_GOTCLIP;  
 
extern char *s_GOTCLIPBOX;  
 
extern char *s_GOTROCKET;  
 
extern char *s_GOTROCKBOX;  
 
extern char *s_GOTCELL;  
 
extern char *s_GOTCELLBOX;  
 
extern char *s_GOTSHELLS;  
 
extern char *s_GOTSHELLBOX;  
 
extern char *s_GOTBACKPACK;  

 
extern char *s_GOTBFG9000;  
 
extern char *s_GOTCHAINGUN;  
 
extern char *s_GOTCHAINSAW;  
 
extern char *s_GOTLAUNCHER;  
 
extern char *s_GOTPLASMA;  
 
extern char *s_GOTSHOTGUN;  
 
extern char *s_GOTSHOTGUN2;  

 
 
 
 
extern char *s_PD_BLUEO;  
 
extern char *s_PD_REDO;  
 
extern char *s_PD_YELLOWO;  
 
extern char *s_PD_BLUEK;  
 
extern char *s_PD_REDK;  
 
extern char *s_PD_YELLOWK;  
 
 
extern char *s_PD_BLUEC;  
 
extern char *s_PD_REDC;  
 
extern char *s_PD_YELLOWC;  
 
extern char *s_PD_BLUES;  
 
extern char *s_PD_REDS;  
 
extern char *s_PD_YELLOWS;  
 
extern char *s_PD_ANY;  
 
extern char *s_PD_ALL3;  
 
extern char *s_PD_ALL6;  

 
 
 
 
extern char *s_GGSAVED;  

 
 
 
 
extern char *s_HUSTR_MSGU;  

 
extern char *s_HUSTR_E1M1;  
 
extern char *s_HUSTR_E1M2;  
 
extern char *s_HUSTR_E1M3;  
 
extern char *s_HUSTR_E1M4;  
 
extern char *s_HUSTR_E1M5;  
 
extern char *s_HUSTR_E1M6;  
 
extern char *s_HUSTR_E1M7;  
 
extern char *s_HUSTR_E1M8;  
 
extern char *s_HUSTR_E1M9;  

 
extern char *s_HUSTR_E2M1;  
 
extern char *s_HUSTR_E2M2;  
 
extern char *s_HUSTR_E2M3;  
 
extern char *s_HUSTR_E2M4;  
 
extern char *s_HUSTR_E2M5;  
 
extern char *s_HUSTR_E2M6;  
 
extern char *s_HUSTR_E2M7;  
 
extern char *s_HUSTR_E2M8;  
 
extern char *s_HUSTR_E2M9;  

 
extern char *s_HUSTR_E3M1;  
 
extern char *s_HUSTR_E3M2;  
 
extern char *s_HUSTR_E3M3;  
 
extern char *s_HUSTR_E3M4;  
 
extern char *s_HUSTR_E3M5;  
 
extern char *s_HUSTR_E3M6;  
 
extern char *s_HUSTR_E3M7;  
 
extern char *s_HUSTR_E3M8;  
 
extern char *s_HUSTR_E3M9;  

 
extern char *s_HUSTR_E4M1;  
 
extern char *s_HUSTR_E4M2;  
 
extern char *s_HUSTR_E4M3;  
 
extern char *s_HUSTR_E4M4;  
 
extern char *s_HUSTR_E4M5;  
 
extern char *s_HUSTR_E4M6;  
 
extern char *s_HUSTR_E4M7;  
 
extern char *s_HUSTR_E4M8;  
 
extern char *s_HUSTR_E4M9;  

 
extern char *s_HUSTR_1;  
 
extern char *s_HUSTR_2;  
 
extern char *s_HUSTR_3;  
 
extern char *s_HUSTR_4;  
 
extern char *s_HUSTR_5;  
 
extern char *s_HUSTR_6;  
 
extern char *s_HUSTR_7;  
 
extern char *s_HUSTR_8;  
 
extern char *s_HUSTR_9;  
 
extern char *s_HUSTR_10;  
 
extern char *s_HUSTR_11;  

 
extern char *s_HUSTR_12;  
 
extern char *s_HUSTR_13;  
 
extern char *s_HUSTR_14;  
 
extern char *s_HUSTR_15;  
 
extern char *s_HUSTR_16;  
 
extern char *s_HUSTR_17;  
 
extern char *s_HUSTR_18;  
 
extern char *s_HUSTR_19;  
 
extern char *s_HUSTR_20;  

 
extern char *s_HUSTR_21;  
 
extern char *s_HUSTR_22;  
 
extern char *s_HUSTR_23;  
 
extern char *s_HUSTR_24;  
 
extern char *s_HUSTR_25;  
 
extern char *s_HUSTR_26;  
 
extern char *s_HUSTR_27;  
 
extern char *s_HUSTR_28;  
 
extern char *s_HUSTR_29;  
 
extern char *s_HUSTR_30;  

 
extern char *s_HUSTR_31;  
 
extern char *s_HUSTR_32;  

 
extern char *s_PHUSTR_1;  
 
extern char *s_PHUSTR_2;  
 
extern char *s_PHUSTR_3;  
 
extern char *s_PHUSTR_4;  
 
extern char *s_PHUSTR_5;  
 
extern char *s_PHUSTR_6;  
 
extern char *s_PHUSTR_7;  
 
extern char *s_PHUSTR_8;  
 
extern char *s_PHUSTR_9;  
 
extern char *s_PHUSTR_10;  
 
extern char *s_PHUSTR_11;  

 
extern char *s_PHUSTR_12;  
 
extern char *s_PHUSTR_13;  
 
extern char *s_PHUSTR_14;  
 
extern char *s_PHUSTR_15;  
 
extern char *s_PHUSTR_16;  
 
extern char *s_PHUSTR_17;  
 
extern char *s_PHUSTR_18;  
 
extern char *s_PHUSTR_19;  
 
extern char *s_PHUSTR_20;  

 
extern char *s_PHUSTR_21;  
 
extern char *s_PHUSTR_22;  
 
extern char *s_PHUSTR_23;  
 
extern char *s_PHUSTR_24;  
 
extern char *s_PHUSTR_25;  
 
extern char *s_PHUSTR_26;  
 
extern char *s_PHUSTR_27;  
 
extern char *s_PHUSTR_28;  
 
extern char *s_PHUSTR_29;  
 
extern char *s_PHUSTR_30;  

 
extern char *s_PHUSTR_31;  
 
extern char *s_PHUSTR_32;  

 
extern char *s_THUSTR_1;  
 
extern char *s_THUSTR_2;  
 
extern char *s_THUSTR_3;  
 
extern char *s_THUSTR_4;  
 
extern char *s_THUSTR_5;  
 
extern char *s_THUSTR_6;  
 
extern char *s_THUSTR_7;  
 
extern char *s_THUSTR_8;  
 
extern char *s_THUSTR_9;  
 
extern char *s_THUSTR_10;  
 
extern char *s_THUSTR_11;  

 
extern char *s_THUSTR_12;  
 
extern char *s_THUSTR_13;  
 
extern char *s_THUSTR_14;  
 
extern char *s_THUSTR_15;  
 
extern char *s_THUSTR_16;  
 
extern char *s_THUSTR_17;  
 
extern char *s_THUSTR_18;  
 
extern char *s_THUSTR_19;  
 
extern char *s_THUSTR_20;  

 
extern char *s_THUSTR_21;  
 
extern char *s_THUSTR_22;  
 
extern char *s_THUSTR_23;  
 
extern char *s_THUSTR_24;  
 
extern char *s_THUSTR_25;  
 
extern char *s_THUSTR_26;  
 
extern char *s_THUSTR_27;  
 
extern char *s_THUSTR_28;  
 
extern char *s_THUSTR_29;  
 
extern char *s_THUSTR_30;  

 
extern char *s_THUSTR_31;  
 
extern char *s_THUSTR_32;  

 
extern char *s_HUSTR_CHATMACRO1;  
 
extern char *s_HUSTR_CHATMACRO2;  
 
extern char *s_HUSTR_CHATMACRO3;  
 
extern char *s_HUSTR_CHATMACRO4;  
 
extern char *s_HUSTR_CHATMACRO5;  
 
extern char *s_HUSTR_CHATMACRO6;  
 
extern char *s_HUSTR_CHATMACRO7;  
 
extern char *s_HUSTR_CHATMACRO8;  
 
extern char *s_HUSTR_CHATMACRO9;  
 
extern char *s_HUSTR_CHATMACRO0;  

 
extern char *s_HUSTR_TALKTOSELF1;  
 
extern char *s_HUSTR_TALKTOSELF2;  
 
extern char *s_HUSTR_TALKTOSELF3;  
 
extern char *s_HUSTR_TALKTOSELF4;  
 
extern char *s_HUSTR_TALKTOSELF5;  

 
extern char *s_HUSTR_MESSAGESENT;  

 
 

 
extern char *s_HUSTR_PLRGREEN;  
 
extern char *s_HUSTR_PLRINDIGO;  
 
extern char *s_HUSTR_PLRBROWN;  
 
extern char *s_HUSTR_PLRRED;  

 
 
extern char sc_HUSTR_KEYGREEN;  
 
extern char sc_HUSTR_KEYINDIGO;  
 
extern char sc_HUSTR_KEYBROWN;  
 
extern char sc_HUSTR_KEYRED;  

 
 
 

 
extern char *s_AMSTR_FOLLOWON;  
 
extern char *s_AMSTR_FOLLOWOFF;  

 
extern char *s_AMSTR_GRIDON;  
 
extern char *s_AMSTR_GRIDOFF;  

 
extern char *s_AMSTR_MARKEDSPOT;  
 
extern char *s_AMSTR_MARKSCLEARED;  

 
 
 

 
extern char *s_STSTR_MUS;  
 
extern char *s_STSTR_NOMUS;  
 
extern char *s_STSTR_DQDON;  
 
extern char *s_STSTR_DQDOFF;  

 
extern char *s_STSTR_KFAADDED;  
 
extern char *s_STSTR_FAADDED;  

 
extern char *s_STSTR_NCON;  
 
extern char *s_STSTR_NCOFF;  

 
extern char *s_STSTR_BEHOLD;  
 
extern char *s_STSTR_BEHOLDX;  

extern char* s_STSTR_LEGEND;  

 
extern char *s_STSTR_CHOPPERS;  
 
extern char *s_STSTR_CLEV;  

 
extern char *s_STSTR_COMPON;  
 
extern char *s_STSTR_COMPOFF;  

 
 
 
 
















extern char *s_E1TEXT;  


 


















extern char *s_E2TEXT;  


 


















extern char *s_E3TEXT;  


 

















extern char *s_E4TEXT;  


 

 













extern char *s_C1TEXT;  

 

 


















extern char *s_C2TEXT;  


 

 










extern char *s_C3TEXT;  


 

 
















extern char *s_C4TEXT;  



 

 






extern char *s_C5TEXT;  


 

 




extern char *s_C6TEXT;  


 

 













extern char *s_P1TEXT;  


 

 







extern char *s_P2TEXT;  


 

 











extern char *s_P3TEXT;  

 

 













extern char *s_P4TEXT;  

 

 





extern char *s_P5TEXT;  

 

 




extern char *s_P6TEXT;  


 













extern char *s_T1TEXT;  


 










extern char *s_T2TEXT;  


 









extern char *s_T3TEXT;  

 












extern char *s_T4TEXT;  


 






extern char *s_T5TEXT;  


 











extern char *s_T6TEXT;  


 
 
 
 
extern char *s_CC_ZOMBIE;  
 
extern char *s_CC_SHOTGUN;  
 
extern char *s_CC_HEAVY;  
 
extern char *s_CC_IMP;  
 
extern char *s_CC_DEMON;  
 
extern char *s_CC_LOST;  
 
extern char *s_CC_CACO;  
 
extern char *s_CC_HELL;  
 
extern char *s_CC_BARON;  
 
extern char *s_CC_ARACH;  
 
extern char *s_CC_PAIN;  
 
extern char *s_CC_REVEN;  
 
extern char *s_CC_MANCU;  
 
extern char *s_CC_ARCH;  
 
extern char *s_CC_SPIDER;  
 
extern char *s_CC_CYBER;  
 
extern char *s_CC_HERO;  

 
 
extern char *bgflatE1;
 
extern char *bgflatE2;
 
extern char *bgflatE3;
 
extern char *bgflatE4;

 
extern char *bgflat06;
 
extern char *bgflat11;
 
extern char *bgflat20;
 
extern char *bgflat30;
 
extern char *bgflat15;
 
extern char *bgflat31;

 
extern char *bgcastcall;

 
 
extern char *startup1;
 
extern char *startup2;
 
extern char *startup3;
 
extern char *startup4;
 
extern char *startup5;

 
extern char *savegamename;



 
 
 
 
 
 
 
 
 
 
 
 
 
 

# 57 "p_spec.c" 2


 
 
 
 
typedef struct
{
    boolean     istexture;
    int         picnum;
    int         basepic;
    int         numpics;
    int         speed;

} anim_t;

 
 
 
typedef struct
{
    char        istexture;             
    char        endname[9];            
    char        startname[9];
    int         speed;
} __attribute__ ((packed)) animdef_t;  



static anim_t*  lastanim;
static anim_t*  anims;                 
static size_t maxanims;

 
static void P_SpawnScrollers(void);

static void P_SpawnFriction(void);     
static void P_SpawnPushers(void);      

extern int allow_pushers;
extern int variable_friction;          

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
void P_InitPicAnims (void)
{
  int         i;
  animdef_t   *animdefs;  
   

   
  animdefs = (animdef_t *)W_CacheLumpNum (W_GetNumForName( "ANIMATED" ),( PU_STATIC )) ;

  lastanim = anims;
  for (i=0 ; animdefs[i].istexture != -1 ; i++)
  {
     
    if (lastanim >= anims + maxanims)
    {
      size_t newmax = maxanims ? maxanims*2 : 32 ;
      anims = (Z_Realloc)  (  anims  ,   newmax*sizeof(*anims)  , PU_STATIC , 0 ,"p_spec.c",137)  ;    
      lastanim = anims + maxanims;
      maxanims = newmax;
    }

    if (animdefs[i].istexture)
    {
       
      if (R_CheckTextureNumForName(animdefs[i].startname) == -1)
          continue;

      lastanim->picnum = R_TextureNumForName (animdefs[i].endname);
      lastanim->basepic = R_TextureNumForName (animdefs[i].startname);
    }
    else
    {
      if ((W_CheckNumForName)(animdefs[i].startname, ns_flats) == -1)   
          continue;

      lastanim->picnum = R_FlatNumForName (animdefs[i].endname);
      lastanim->basepic = R_FlatNumForName (animdefs[i].startname);
    }

    lastanim->istexture = animdefs[i].istexture;
    lastanim->numpics = lastanim->picnum - lastanim->basepic + 1;

    if (lastanim->numpics < 2)
        I_Error ("P_InitPicAnims: bad cycle from %s to %s",
                  animdefs[i].startname,
                  animdefs[i].endname);

    lastanim->speed = LONG(animdefs[i].speed);  
    lastanim++;
  }
  (Z_ChangeTag)( animdefs , PU_CACHE ,    "p_spec.c",171) ;  
}

 
 
 
 
 

 
 
 
 
 
 
 
 
 
side_t* getSide
( int           currentSector,
  int           line,
  int           side )
{
  return &sides[ (sectors[currentSector].lines[line])->sidenum[side] ];
}


 
 
 
 
 
 
 
 
 
sector_t* getSector
( int           currentSector,
  int           line,
  int           side )
{
  return sides[ (sectors[currentSector].lines[line])->sidenum[side] ].sector;
}


 
 
 
 
 
 
 
 
 
int twoSided
( int   sector,
  int   line )
{
   
   

  return compatibility?
    (sectors[sector].lines[line])->flags & 4 
    :
    (sectors[sector].lines[line])->sidenum[1] != -1;
}


 
 
 
 
 
 
 
sector_t* getNextSector
( line_t*       line,
  sector_t*     sec )
{
   
   
   

  if (compatibility)
  {
    if (!(line->flags & 4 ))
      return 0 ;
  }

  if (line->frontsector == sec)
    if (compatibility || line->backsector!=sec)
      return line->backsector;  
    else                        
      return 0 ;              
  return line->frontsector;
}


 
 
 
 
 
 
fixed_t P_FindLowestFloorSurrounding(sector_t* sec)
{
  int                 i;
  line_t*             check;
  sector_t*           other;
  fixed_t             floor = sec->floorheight;

  for (i=0 ;i < sec->linecount ; i++)
  {
    check = sec->lines[i];
    other = getNextSector(check,sec);

    if (!other)
      continue;

    if (other->floorheight < floor)
      floor = other->floorheight;
  }
  return floor;
}


 
 
 
 
 
 
 
 
 
fixed_t P_FindHighestFloorSurrounding(sector_t *sec)
{
  int i;
  line_t* check;
  sector_t* other;
  fixed_t floor = -500* (1<< 16 ) ;

   
   
  if (!compatibility)           
    floor = -32000* (1<< 16 ) ;    

  for (i=0 ;i < sec->linecount ; i++)
  {
    check = sec->lines[i];
    other = getNextSector(check,sec);

    if (!other)
      continue;

    if (other->floorheight > floor)
      floor = other->floorheight;
  }
  return floor;
}


 
 
 
 
 
 
 
 
 
 
fixed_t P_FindNextHighestFloor(sector_t *sec, int currentheight)
{
  sector_t *other;
  int i;

  for (i=0 ;i < sec->linecount ; i++)
    if ((other = getNextSector(sec->lines[i],sec)) &&
         other->floorheight > currentheight)
    {
      int height = other->floorheight;
      while (++i < sec->linecount)
        if ((other = getNextSector(sec->lines[i],sec)) &&
            other->floorheight < height &&
            other->floorheight > currentheight)
          height = other->floorheight;
      return height;
    }
  return currentheight;
}


 
 
 
 
 
 
 
 
 
 
fixed_t P_FindNextLowestFloor(sector_t *sec, int currentheight)
{
  sector_t *other;
  int i;

  for (i=0 ;i < sec->linecount ; i++)
    if ((other = getNextSector(sec->lines[i],sec)) &&
         other->floorheight < currentheight)
    {
      int height = other->floorheight;
      while (++i < sec->linecount)
        if ((other = getNextSector(sec->lines[i],sec)) &&
            other->floorheight > height &&
            other->floorheight < currentheight)
          height = other->floorheight;
      return height;
    }
  return currentheight;
}


 
 
 
 
 
 
 
 
 
 
fixed_t P_FindNextLowestCeiling(sector_t *sec, int currentheight)
{
  sector_t *other;
  int i;

  for (i=0 ;i < sec->linecount ; i++)
    if ((other = getNextSector(sec->lines[i],sec)) &&
        other->ceilingheight < currentheight)
    {
      int height = other->ceilingheight;
      while (++i < sec->linecount)
        if ((other = getNextSector(sec->lines[i],sec)) &&
            other->ceilingheight > height &&
            other->ceilingheight < currentheight)
          height = other->ceilingheight;
      return height;
    }
  return currentheight;
}


 
 
 
 
 
 
 
 
 
 
fixed_t P_FindNextHighestCeiling(sector_t *sec, int currentheight)
{
  sector_t *other;
  int i;

  for (i=0 ;i < sec->linecount ; i++)
    if ((other = getNextSector(sec->lines[i],sec)) &&
         other->ceilingheight > currentheight)
    {
      int height = other->ceilingheight;
      while (++i < sec->linecount)
        if ((other = getNextSector(sec->lines[i],sec)) &&
            other->ceilingheight < height &&
            other->ceilingheight > currentheight)
          height = other->ceilingheight;
      return height;
    }
  return currentheight;
}


 
 
 
 
 
 
 
 
 
fixed_t P_FindLowestCeilingSurrounding(sector_t* sec)
{
  int                 i;
  line_t*             check;
  sector_t*           other;
  fixed_t             height = ((int)0x7fffffff) ;

  if (!compatibility) height = 32000* (1<< 16 ) ;  
                                                
  for (i=0 ;i < sec->linecount ; i++)
  {
    check = sec->lines[i];
    other = getNextSector(check,sec);

    if (!other)
      continue;

    if (other->ceilingheight < height)
      height = other->ceilingheight;
  }
  return height;
}


 
 
 
 
 
 
 
 
 
fixed_t P_FindHighestCeilingSurrounding(sector_t* sec)
{
  int             i;
  line_t* check;
  sector_t*       other;
  fixed_t height = 0;

   
   
  if (!compatibility) height = -32000* (1<< 16 ) ;  
                                                 
  for (i=0 ;i < sec->linecount ; i++)
  {
    check = sec->lines[i];
    other = getNextSector(check,sec);

    if (!other)
      continue;

    if (other->ceilingheight > height)
      height = other->ceilingheight;
  }
  return height;
}


 
 
 
 
 
 
 
 
 
 
 
fixed_t P_FindShortestTextureAround(int secnum)
{
  int minsize = ((int)0x7fffffff) ;
  side_t*     side;
  int i;
  sector_t *sec = &sectors[secnum];

  if (!compatibility)
    minsize = 32000<< 16 ;  

  for (i = 0; i < sec->linecount; i++)
  {
    if (twoSided(secnum, i))
    {
      side = getSide(secnum,i,0);
      if (side->bottomtexture > 0)   
        if (textureheight[side->bottomtexture] < minsize)
          minsize = textureheight[side->bottomtexture];
      side = getSide(secnum,i,1);
      if (side->bottomtexture > 0)   
        if (textureheight[side->bottomtexture] < minsize)
          minsize = textureheight[side->bottomtexture];
    }
  }
  return minsize;
}


 
 
 
 
 
 
 
 
 
 
 
fixed_t P_FindShortestUpperAround(int secnum)
{
  int minsize = ((int)0x7fffffff) ;
  side_t*     side;
  int i;
  sector_t *sec = &sectors[secnum];

  if (!compatibility)
    minsize = 32000<< 16 ;  
                                
  for (i = 0; i < sec->linecount; i++)
  {
    if (twoSided(secnum, i))
    {
      side = getSide(secnum,i,0);
      if (side->toptexture > 0)      
        if (textureheight[side->toptexture] < minsize)
          minsize = textureheight[side->toptexture];
      side = getSide(secnum,i,1);
      if (side->toptexture > 0)      
        if (textureheight[side->toptexture] < minsize)
          minsize = textureheight[side->toptexture];
    }
  }
  return minsize;
}


 
 
 
 
 
 
 
 
 
 
 
 
 
 
sector_t *P_FindModelFloorSector(fixed_t floordestheight,int secnum)
{
  int i;
  sector_t *sec= 0 ;
  int linecount;

  sec = &sectors[secnum];  
   
   
  linecount = sec->linecount;
  for (i = 0; i < (demo_compatibility && sec->linecount<linecount?
                   sec->linecount : linecount); i++)
  {
    if ( twoSided(secnum, i) )
    {
      if (getSide(secnum,i,0)->sector-sectors == secnum)
          sec = getSector(secnum,i,1);
      else
          sec = getSector(secnum,i,0);

      if (sec->floorheight == floordestheight)
        return sec;
    }
  }
  return 0 ;
}


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
sector_t *P_FindModelCeilingSector(fixed_t ceildestheight,int secnum)
{
  int i;
  sector_t *sec= 0 ;
  int linecount;

  sec = &sectors[secnum];  
   
   
  linecount = sec->linecount;
  for (i = 0; i < (demo_compatibility && sec->linecount<linecount?
                   sec->linecount : linecount); i++)
  {
    if ( twoSided(secnum, i) )
    {
      if (getSide(secnum,i,0)->sector-sectors == secnum)
          sec = getSector(secnum,i,1);
      else
          sec = getSector(secnum,i,0);

      if (sec->ceilingheight == ceildestheight)
        return sec;
    }
  }
  return 0 ;
}

 
 
 

 
 

int P_FindSectorFromLineTag(const line_t *line, int start)
{
  start = start >= 0 ? sectors[start].nexttag :
    sectors[(unsigned) line->tag % (unsigned) numsectors].firsttag;
  while (start >= 0 && sectors[start].tag != line->tag)
    start = sectors[start].nexttag;
  return start;
}

 

int P_FindLineFromLineTag(const line_t *line, int start)
{
  start = start >= 0 ? lines[start].nexttag :
    lines[(unsigned) line->tag % (unsigned) numlines].firsttag;
  while (start >= 0 && lines[start].tag != line->tag)
    start = lines[start].nexttag;
  return start;
}

 
static void P_InitTagLists(void)
{
  register int i;

  for (i=numsectors; --i>=0; )         
    sectors[i].firsttag = -1;
  for (i=numsectors; --i>=0; )         
    {                                  
      int j = (unsigned) sectors[i].tag % (unsigned) numsectors;  
      sectors[i].nexttag = sectors[j].firsttag;    
      sectors[j].firsttag = i;
    }

   

  for (i=numlines; --i>=0; )         
    lines[i].firsttag = -1;
  for (i=numlines; --i>=0; )         
    {                                
      int j = (unsigned) lines[i].tag % (unsigned) numlines;  
      lines[i].nexttag = lines[j].firsttag;    
      lines[j].firsttag = i;
    }
}

 
 
 
 
 
 
 
int P_FindMinSurroundingLight
( sector_t*     sector,
  int           max )
{
  int         i;
  int         min;
  line_t*     line;
  sector_t*   check;

  min = max;
  for (i=0 ; i < sector->linecount ; i++)
  {
    line = sector->lines[i];
    check = getNextSector(line,sector);

    if (!check)
      continue;

    if (check->lightlevel < min)
      min = check->lightlevel;
  }
  return min;
}


 
 
 
 
 
 
 
 
 
 
 
 
boolean P_CanUnlockGenDoor
( line_t* line,
  player_t* player)
{
   
  int skulliscard = (line->special & 0x0200 )>> 9 ;

   
  switch((line->special & 0x01c0 )>> 6 )
  {
    case AnyKey:
      if
      (
        !player->cards[it_redcard] &&
        !player->cards[it_redskull] &&
        !player->cards[it_bluecard] &&
        !player->cards[it_blueskull] &&
        !player->cards[it_yellowcard] &&
        !player->cards[it_yellowskull]
      )
      {
        player->message = s_PD_ANY;  
        S_StartSound(player->mo,sfx_oof);              
        return false;
      }
      break;
    case RCard:
      if
      (
        !player->cards[it_redcard] &&
        (!skulliscard || !player->cards[it_redskull])
      )
      {
        player->message = skulliscard? s_PD_REDK : s_PD_REDC;  
        S_StartSound(player->mo,sfx_oof);              
        return false;
      }
      break;
    case BCard:
      if
      (
        !player->cards[it_bluecard] &&
        (!skulliscard || !player->cards[it_blueskull])
      )
      {
        player->message = skulliscard? s_PD_BLUEK : s_PD_BLUEC;  
        S_StartSound(player->mo,sfx_oof);              
        return false;
      }
      break;
    case YCard:
      if
      (
        !player->cards[it_yellowcard] &&
        (!skulliscard || !player->cards[it_yellowskull])
      )
      {
        player->message = skulliscard? s_PD_YELLOWK : s_PD_YELLOWC;  
        S_StartSound(player->mo,sfx_oof);              
        return false;
      }
      break;
    case RSkull:
      if
      (
        !player->cards[it_redskull] &&
        (!skulliscard || !player->cards[it_redcard])
      )
      {
        player->message = skulliscard? s_PD_REDK : s_PD_REDS;  
        S_StartSound(player->mo,sfx_oof);              
        return false;
      }
      break;
    case BSkull:
      if
      (
        !player->cards[it_blueskull] &&
        (!skulliscard || !player->cards[it_bluecard])
      )
      {
        player->message = skulliscard? s_PD_BLUEK : s_PD_BLUES;  
        S_StartSound(player->mo,sfx_oof);              
        return false;
      }
      break;
    case YSkull:
      if
      (
        !player->cards[it_yellowskull] &&
        (!skulliscard || !player->cards[it_yellowcard])
      )
      {
        player->message = skulliscard? s_PD_YELLOWK : s_PD_YELLOWS;  
        S_StartSound(player->mo,sfx_oof);              
        return false;
      }
      break;
    case AllKeys:
      if
      (
        !skulliscard &&
        (
          !player->cards[it_redcard] ||
          !player->cards[it_redskull] ||
          !player->cards[it_bluecard] ||
          !player->cards[it_blueskull] ||
          !player->cards[it_yellowcard] ||
          !player->cards[it_yellowskull]
        )
      )
      {
        player->message = s_PD_ALL6;  
        S_StartSound(player->mo,sfx_oof);              
        return false;
      }
      if
      (
        skulliscard &&
        (
          (!player->cards[it_redcard] &&
            !player->cards[it_redskull]) ||
          (!player->cards[it_bluecard] &&
            !player->cards[it_blueskull]) ||
          (!player->cards[it_yellowcard] &&
            !player->cards[it_yellowskull])
        )
      )
      {
        player->message = s_PD_ALL3;  
        S_StartSound(player->mo,sfx_oof);              
        return false;
      }
      break;
  }
  return true;
}


 
 
 
 
 
 
 
 
 
 
 
int P_SectorActive(special_e t,sector_t *sec)
{
  if (demo_compatibility)   
    return sec->floordata || sec->ceilingdata || sec->lightingdata;
  else
    switch (t)              
    {
      case floor_special:
        return (int)sec->floordata;
      case ceiling_special:
        return (int)sec->ceilingdata;
      case lighting_special:
        return (int)sec->lightingdata;
    }
  return 1;  
}


 
 
 
 
 
 
 
 
 
 
 
 
int P_CheckTag(line_t *line)
{
  if (compatibility)         
    return 1;

  if (line->tag)             
    return 1;

  switch(line->special)
  {
    case 1:                  
    case 26:
    case 27:
    case 28:
    case 31:
    case 32:
    case 33:
    case 34:
    case 117:
    case 118:

    case 139:                
    case 170:
    case 79:
    case 35:
    case 138:
    case 171:
    case 81:
    case 13:
    case 192:
    case 169:
    case 80:
    case 12:
    case 194:
    case 173:
    case 157:
    case 104:
    case 193:
    case 172:
    case 156:
    case 17:

    case 195:                
    case 174:
    case 97:
    case 39:
    case 126:
    case 125:
    case 210:
    case 209:
    case 208:
    case 207:

    case 11:                 
    case 52:
    case 197:
    case 51:
    case 124:
    case 198:

    case 48:                 
    case 85:
      return 1;    

    default:
      break;
  }
  return 0;        
}


 
 
 
 
 
 
 
 
 
boolean P_IsSecret(sector_t *sec)
{
  return (sec->special==9 || (sec->special& 0x80 ));
}


 
 
 
 
 
 
 
 
 
boolean P_WasSecret(sector_t *sec)
{
  return (sec->oldspecial==9 || (sec->oldspecial& 0x80 ));
}


 
 
 
 
 
 
 
 

 
 
 
 
 
 
 
 
 
 
 
void P_CrossSpecialLine
( int           linenum,
  int           side,
  mobj_t*       thing )
{
  line_t*     line;
  int         ok;

  line = &lines[linenum];

   
  if (!thing->player)
  {
     
    switch(thing->type)
    {
      case MT_ROCKET:
      case MT_PLASMA:
      case MT_BFG:
      case MT_TROOPSHOT:
      case MT_HEADSHOT:
      case MT_BRUISERSHOT:
        return;
        break;

      default: break;
    }
  }

   
  if (!demo_compatibility)  
  {
     
     
    int (*linefunc)(line_t *line)= 0 ;

     
    if ((unsigned)line->special >= 0x6000 )
    {
      if (!thing->player)
        if ((line->special & 0x0c00 ) || !(line->special & 0x0020 ))
          return;      
      if (!line->tag)  
        return;
      linefunc = EV_DoGenFloor;
    }
    else if ((unsigned)line->special >= 0x4000 )
    {
      if (!thing->player)
        if ((line->special & 0x0c00 ) || !(line->special & 0x0020 ))
          return;      
      if (!line->tag)  
        return;
      linefunc = EV_DoGenCeiling;
    }
    else if ((unsigned)line->special >= 0x3c00 )
    {
      if (!thing->player)
      {
        if (!(line->special & 0x0080 ))
          return;                     
        if (line->flags & 32 )  
          return;
      }
      if (!line->tag)  
        return;
      linefunc = EV_DoGenDoor;
    }
    else if ((unsigned)line->special >= 0x3800 )
    {
      if (!thing->player)
        return;                      
      if (((line->special& 0x0007 )==WalkOnce) || ((line->special& 0x0007 )==WalkMany))
      {  
        if (!P_CanUnlockGenDoor(line,thing->player))
          return;
      }
      else
        return;
      linefunc = EV_DoGenLockedDoor;
    }
    else if ((unsigned)line->special >= 0x3400 )
    {
      if (!thing->player)
        if (!(line->special & 0x0020 ))
          return;  
      if (!line->tag)  
        return;
      linefunc = EV_DoGenLift;
    }
    else if ((unsigned)line->special >= 0x3000 )
    {
      if (!thing->player)
        if (!(line->special & 0x0020 ))
          return;  
      if (!line->tag)  
        return;
      linefunc = EV_DoGenStairs;
    }

    if (linefunc)  
      switch((line->special & 0x0007 ) >> 0 )
      {
        case WalkOnce:
          if (linefunc(line))
            line->special = 0;     
          return;
        case WalkMany:
          linefunc(line);
          return;
        default:                   
          return;
      }
  }

  if (!thing->player)
  {
    ok = 0;
    switch(line->special)
    {
      case 39:       
      case 97:       
      case 125:      
      case 126:      
      case 4:        
      case 10:       
      case 88:       
         
      case 208:      
      case 207:
      case 243:      
      case 244:      
      case 262:      
      case 263:      
      case 264:      
      case 265:      
      case 266:
      case 267:
      case 268:
      case 269:
        ok = 1;
        break;
    }
    if (!ok)
      return;
  }

  if (!P_CheckTag(line))   
    return;

   
   

  switch (line->special)
  {
       

    case 2:
       
      if (EV_DoDoor(line,open) || demo_compatibility)
        line->special = 0;
      break;

    case 3:
       
      if (EV_DoDoor(line,close) || demo_compatibility)
        line->special = 0;
      break;

    case 4:
       
      if (EV_DoDoor(line,normal) || demo_compatibility)
        line->special = 0;
      break;

    case 5:
       
      if (EV_DoFloor(line,raiseFloor) || demo_compatibility)
        line->special = 0;
      break;

    case 6:
       
      if (EV_DoCeiling(line,fastCrushAndRaise) || demo_compatibility)
        line->special = 0;
      break;

    case 8:
       
      if (EV_BuildStairs(line,build8) || demo_compatibility)
        line->special = 0;
      break;

    case 10:
       
      if (EV_DoPlat(line,downWaitUpStay,0) || demo_compatibility)
        line->special = 0;
      break;

    case 12:
       
      if (EV_LightTurnOn(line,0) || demo_compatibility)
        line->special = 0;
      break;

    case 13:
       
      if (EV_LightTurnOn(line,255) || demo_compatibility)
        line->special = 0;
      break;

    case 16:
       
      if (EV_DoDoor(line,close30ThenOpen) || demo_compatibility)
        line->special = 0;
      break;

    case 17:
       
      if (EV_StartLightStrobing(line) || demo_compatibility)
        line->special = 0;
      break;

    case 19:
       
      if (EV_DoFloor(line,lowerFloor) || demo_compatibility)
        line->special = 0;
      break;

    case 22:
       
      if (EV_DoPlat(line,raiseToNearestAndChange,0) || demo_compatibility)
        line->special = 0;
      break;

    case 25:
       
      if (EV_DoCeiling(line,crushAndRaise) || demo_compatibility)
        line->special = 0;
      break;

    case 30:
       
       
      if (EV_DoFloor(line,raiseToTexture) || demo_compatibility)
        line->special = 0;
      break;

    case 35:
       
      if (EV_LightTurnOn(line,35) || demo_compatibility)
        line->special = 0;
      break;

    case 36:
       
      if (EV_DoFloor(line,turboLower) || demo_compatibility)
        line->special = 0;
      break;

    case 37:
       
      if (EV_DoFloor(line,lowerAndChange) || demo_compatibility)
        line->special = 0;
      break;

    case 38:
       
      if (EV_DoFloor(line, lowerFloorToLowest) || demo_compatibility)
        line->special = 0;
      break;

    case 39:
       
      if (EV_Teleport(line, side, thing) || demo_compatibility)
        line->special = 0;
      break;

    case 40:
       
      if (demo_compatibility)
      {
        EV_DoCeiling( line, raiseToHighest );
        EV_DoFloor( line, lowerFloorToLowest );  
        line->special = 0;
      }
      else
        if (EV_DoCeiling(line, raiseToHighest))
          line->special = 0;
      break;

    case 44:
       
      if (EV_DoCeiling(line, lowerAndCrush) || demo_compatibility)
        line->special = 0;
      break;

    case 52:
       
      G_ExitLevel ();
      break;

    case 53:
       
      if (EV_DoPlat(line,perpetualRaise,0) || demo_compatibility)
        line->special = 0;
      break;

    case 54:
       
      if (EV_StopPlat(line) || demo_compatibility)
        line->special = 0;
      break;

    case 56:
       
      if (EV_DoFloor(line,raiseFloorCrush) || demo_compatibility)
        line->special = 0;
      break;

    case 57:
       
      if (EV_CeilingCrushStop(line) || demo_compatibility)
        line->special = 0;
      break;

    case 58:
       
      if (EV_DoFloor(line,raiseFloor24) || demo_compatibility)
        line->special = 0;
      break;

    case 59:
       
      if (EV_DoFloor(line,raiseFloor24AndChange) || demo_compatibility)
        line->special = 0;
      break;

    case 100:
       
      if (EV_BuildStairs(line,turbo16) || demo_compatibility)
        line->special = 0;
      break;

    case 104:
       
      if (EV_TurnTagLightsOff(line) || demo_compatibility)
        line->special = 0;
      break;

    case 108:
       
      if (EV_DoDoor(line,blazeRaise) || demo_compatibility)
        line->special = 0;
      break;

    case 109:
       
      if (EV_DoDoor (line,blazeOpen) || demo_compatibility)
        line->special = 0;
      break;

    case 110:
       
      if (EV_DoDoor (line,blazeClose) || demo_compatibility)
        line->special = 0;
      break;

    case 119:
       
      if (EV_DoFloor(line,raiseFloorToNearest) || demo_compatibility)
        line->special = 0;
      break;

    case 121:
       
      if (EV_DoPlat(line,blazeDWUS,0) || demo_compatibility)
        line->special = 0;
      break;

    case 124:
       
      G_SecretExitLevel ();
      break;

    case 125:
       
      if (!thing->player &&
          (EV_Teleport(line, side, thing) || demo_compatibility))
        line->special = 0;
      break;

    case 130:
       
      if (EV_DoFloor(line,raiseFloorTurbo) || demo_compatibility)
        line->special = 0;
      break;

    case 141:
       
      if (EV_DoCeiling(line,silentCrushAndRaise) || demo_compatibility)
        line->special = 0;
      break;

       

    case 72:
       
      EV_DoCeiling( line, lowerAndCrush );
      break;

    case 73:
       
      EV_DoCeiling(line,crushAndRaise);
      break;

    case 74:
       
      EV_CeilingCrushStop(line);
      break;

    case 75:
       
      EV_DoDoor(line,close);
      break;

    case 76:
       
      EV_DoDoor(line,close30ThenOpen);
      break;

    case 77:
       
      EV_DoCeiling(line,fastCrushAndRaise);
      break;

    case 79:
       
      EV_LightTurnOn(line,35);
      break;

    case 80:
       
      EV_LightTurnOn(line,0);
      break;

    case 81:
       
      EV_LightTurnOn(line,255);
      break;

    case 82:
       
      EV_DoFloor( line, lowerFloorToLowest );
      break;

    case 83:
       
      EV_DoFloor(line,lowerFloor);
      break;

    case 84:
       
      EV_DoFloor(line,lowerAndChange);
      break;

    case 86:
       
      EV_DoDoor(line,open);
      break;

    case 87:
       
      EV_DoPlat(line,perpetualRaise,0);
      break;

    case 88:
       
      EV_DoPlat(line,downWaitUpStay,0);
      break;

    case 89:
       
      EV_StopPlat(line);
      break;

    case 90:
       
      EV_DoDoor(line,normal);
      break;

    case 91:
       
      EV_DoFloor(line,raiseFloor);
      break;

    case 92:
       
      EV_DoFloor(line,raiseFloor24);
      break;

    case 93:
       
      EV_DoFloor(line,raiseFloor24AndChange);
      break;

    case 94:
       
      EV_DoFloor(line,raiseFloorCrush);
      break;

    case 95:
       
       
      EV_DoPlat(line,raiseToNearestAndChange,0);
      break;

    case 96:
       
       
      EV_DoFloor(line,raiseToTexture);
      break;

    case 97:
       
      EV_Teleport( line, side, thing );
      break;

    case 98:
       
      EV_DoFloor(line,turboLower);
      break;

    case 105:
       
      EV_DoDoor (line,blazeRaise);
      break;

    case 106:
       
      EV_DoDoor (line,blazeOpen);
      break;

    case 107:
       
      EV_DoDoor (line,blazeClose);
      break;

    case 120:
       
      EV_DoPlat(line,blazeDWUS,0);
      break;

    case 126:
       
      if (!thing->player)
        EV_Teleport( line, side, thing );
      break;

    case 128:
       
      EV_DoFloor(line,raiseFloorToNearest);
      break;

    case 129:
       
      EV_DoFloor(line,raiseFloorTurbo);
      break;

       

       
       

       
       
       

       

    default:
      if (!demo_compatibility)
        switch (line->special)
        {
           

          case 142:
             
             
            if (EV_DoFloor(line,raiseFloor512))
              line->special = 0;
            break;

          case 143:
             
             
            if (EV_DoPlat(line,raiseAndChange,24))
              line->special = 0;
            break;

          case 144:
             
             
            if (EV_DoPlat(line,raiseAndChange,32))
              line->special = 0;
            break;

          case 145:
             
             
            if (EV_DoCeiling( line, lowerToFloor ))
              line->special = 0;
            break;

          case 146:
             
             
            if (EV_DoDonut(line))
              line->special = 0;
            break;

          case 199:
             
             
            if (EV_DoCeiling(line,lowerToLowest))
              line->special = 0;
            break;

          case 200:
             
             
            if (EV_DoCeiling(line,lowerToMaxFloor))
              line->special = 0;
            break;

          case 207:
             
            if (EV_SilentTeleport(line, side, thing))
              line->special = 0;
            break;

             
          case 153:  
             
             
            if (EV_DoChange(line,trigChangeOnly))
              line->special = 0;
            break;

          case 239:  
             
             
            if (EV_DoChange(line,numChangeOnly))
              line->special = 0;
            break;

          case 219:
             
             
            if (EV_DoFloor(line,lowerFloorToNearest))
              line->special = 0;
            break;

          case 227:
             
             
            if (EV_DoElevator(line,elevateUp))
              line->special = 0;
            break;

          case 231:
             
             
            if (EV_DoElevator(line,elevateDown))
              line->special = 0;
            break;

          case 235:
             
             
            if (EV_DoElevator(line,elevateCurrent))
              line->special = 0;
            break;

          case 243:  
             
            if (EV_SilentLineTeleport(line, side, thing, false))
              line->special = 0;
            break;

          case 262:  
            if (EV_SilentLineTeleport(line, side, thing, true))
              line->special = 0;
            break;

          case 264:  
            if (!thing->player &&
                EV_SilentLineTeleport(line, side, thing, true))
              line->special = 0;
            break;

          case 266:  
            if (!thing->player &&
                EV_SilentLineTeleport(line, side, thing, false))
              line->special = 0;
            break;

          case 268:  
            if (!thing->player && EV_SilentTeleport(line, side, thing))
              line->special = 0;
            break;

           

           

           
           

          case 147:
             
             
            EV_DoFloor(line,raiseFloor512);
            break;

          case 148:
             
             
            EV_DoPlat(line,raiseAndChange,24);
            break;

          case 149:
             
             
            EV_DoPlat(line,raiseAndChange,32);
            break;

          case 150:
             
             
            EV_DoCeiling(line,silentCrushAndRaise);
            break;

          case 151:
             
             
             
            EV_DoCeiling( line, raiseToHighest );
            EV_DoFloor( line, lowerFloorToLowest );
            break;

          case 152:
             
             
            EV_DoCeiling( line, lowerToFloor );
            break;

             
          case 256:
             
             
            EV_BuildStairs(line,build8);
            break;

             
          case 257:
             
             
            EV_BuildStairs(line,turbo16);
            break;

          case 155:
             
             
            EV_DoDonut(line);
            break;

          case 156:
             
             
            EV_StartLightStrobing(line);
            break;

          case 157:
             
             
            EV_TurnTagLightsOff(line);
            break;

          case 201:
             
             
            EV_DoCeiling(line,lowerToLowest);
            break;

          case 202:
             
             
            EV_DoCeiling(line,lowerToMaxFloor);
            break;

          case 208:
             
            EV_SilentTeleport(line, side, thing);
            break;

          case 212:  
             
             
            EV_DoPlat(line,toggleUpDn,0);
            break;

           
          case 154:  
             
             
            EV_DoChange(line,trigChangeOnly);
            break;

          case 240:  
             
             
            EV_DoChange(line,numChangeOnly);
            break;

          case 220:
             
             
            EV_DoFloor(line,lowerFloorToNearest);
            break;

          case 228:
             
             
            EV_DoElevator(line,elevateUp);
            break;

          case 232:
             
             
            EV_DoElevator(line,elevateDown);
            break;

          case 236:
             
             
            EV_DoElevator(line,elevateCurrent);
            break;

          case 244:  
             
            EV_SilentLineTeleport(line, side, thing, false);
            break;

          case 263:  
            EV_SilentLineTeleport(line, side, thing, true);
            break;

          case 265:  
            if (!thing->player)
              EV_SilentLineTeleport(line, side, thing, true);
            break;

          case 267:  
            if (!thing->player)
              EV_SilentLineTeleport(line, side, thing, false);
            break;

          case 269:  
            if (!thing->player)
              EV_SilentTeleport(line, side, thing);
            break;

             
        }
      break;
  }
}

 
 
 
 
 
 
 
 
 
 
void P_ShootSpecialLine
( mobj_t*       thing,
  line_t*       line )
{
   
  if (!demo_compatibility)
  {
     
     
    int (*linefunc)(line_t *line)= 0 ;

     
    if ((unsigned)line->special >= 0x6000 )
    {
      if (!thing->player)
        if ((line->special & 0x0c00 ) || !(line->special & 0x0020 ))
          return;    
      if (!line->tag)  
        return;

      linefunc = EV_DoGenFloor;
    }
    else if ((unsigned)line->special >= 0x4000 )
    {
      if (!thing->player)
        if ((line->special & 0x0c00 ) || !(line->special & 0x0020 ))
          return;    
      if (!line->tag)  
        return;
      linefunc = EV_DoGenCeiling;
    }
    else if ((unsigned)line->special >= 0x3c00 )
    {
      if (!thing->player)
      {
        if (!(line->special & 0x0080 ))
          return;    
        if (line->flags & 32 )  
          return;
      }
      if (!line->tag)  
        return;
      linefunc = EV_DoGenDoor;
    }
    else if ((unsigned)line->special >= 0x3800 )
    {
      if (!thing->player)
        return;    
      if (((line->special& 0x0007 )==GunOnce) || ((line->special& 0x0007 )==GunMany))
      {  
        if (!P_CanUnlockGenDoor(line,thing->player))
          return;
      }
      else
        return;
      if (!line->tag)  
        return;

      linefunc = EV_DoGenLockedDoor;
    }
    else if ((unsigned)line->special >= 0x3400 )
    {
      if (!thing->player)
        if (!(line->special & 0x0020 ))
          return;  
      linefunc = EV_DoGenLift;
    }
    else if ((unsigned)line->special >= 0x3000 )
    {
      if (!thing->player)
        if (!(line->special & 0x0020 ))
          return;  
      if (!line->tag)  
        return;
      linefunc = EV_DoGenStairs;
    }
    else if ((unsigned)line->special >= 0x2F80 )
    {
      if (!thing->player)
        if (!(line->special & 0x0020 ))
          return;  
      if (!line->tag)  
        return;
      linefunc = EV_DoGenCrusher;
    }

    if (linefunc)
      switch((line->special & 0x0007 ) >> 0 )
      {
        case GunOnce:
          if (linefunc(line))
            P_ChangeSwitchTexture(line,0);
          return;
        case GunMany:
          if (linefunc(line))
            P_ChangeSwitchTexture(line,1);
          return;
        default:   
          return;
      }
  }

   
  if (!thing->player)
  {
    int ok = 0;
    switch(line->special)
    {
      case 46:
         
        ok = 1;
        break;
    }
    if (!ok)
      return;
  }

  if (!P_CheckTag(line))   
    return;

  switch(line->special)
  {
    case 24:
       
      if (EV_DoFloor(line,raiseFloor) || demo_compatibility)
        P_ChangeSwitchTexture(line,0);
      break;

    case 46:
       
      EV_DoDoor(line,open);
      P_ChangeSwitchTexture(line,1);
      break;

    case 47:
       
      if (EV_DoPlat(line,raiseToNearestAndChange,0) || demo_compatibility)
        P_ChangeSwitchTexture(line,0);
      break;

     
     

    default:
      if (!demo_compatibility)
        switch (line->special)
        {
          case 197:
             
            P_ChangeSwitchTexture(line,0);
            G_ExitLevel();
            break;

          case 198:
             
            P_ChangeSwitchTexture(line,0);
            G_SecretExitLevel();
            break;
             
        }
      break;
  }
}


 
 
 
 
 
 
 
 
void P_PlayerInSpecialSector (player_t* player)
{
  sector_t*   sector;

  sector = player->mo->subsector->sector;

   
   
  if (player->mo->z != sector->floorheight)
    return;

   
   
  if (sector->special<32)  
  {
    switch (sector->special)
      {
      case 5:
         
        if (!player->powers[pw_ironfeet])
          if (!(leveltime&0x1f))
            P_DamageMobj (player->mo, 0 , 0 , 10);
        break;

      case 7:
         
        if (!player->powers[pw_ironfeet])
          if (!(leveltime&0x1f))
            P_DamageMobj (player->mo, 0 , 0 , 5);
        break;

      case 16:
         
      case 4:
         
        if (!player->powers[pw_ironfeet]
            || (P_Random(pr_slimehurt)<5) )  
        {
          if (!(leveltime&0x1f))
            P_DamageMobj (player->mo, 0 , 0 , 20);
        }
        break;

      case 9:
         
        player->secretcount++;
        sector->special = 0;
        break;

      case 11:
         
        if (compatibility)      
          player->cheats &= ~CF_GODMODE;  
                                          
        if (!(leveltime&0x1f))
          P_DamageMobj (player->mo, 0 , 0 , 20);

        if (player->health <= 10)
          G_ExitLevel();
        break;

      default:
         
        break;
      };
  }
  else  
  {
    switch ((sector->special& 0x60 )>> 5 )
    {
      case 0:  
        break;
      case 1:  
        if (!player->powers[pw_ironfeet])
          if (!(leveltime&0x1f))
            P_DamageMobj (player->mo, 0 , 0 , 5);
        break;
      case 2:  
        if (!player->powers[pw_ironfeet])
          if (!(leveltime&0x1f))
            P_DamageMobj (player->mo, 0 , 0 , 10);
        break;
      case 3:  
        if (!player->powers[pw_ironfeet]
            || (P_Random(pr_slimehurt)<5))   
        {
          if (!(leveltime&0x1f))
            P_DamageMobj (player->mo, 0 , 0 , 20);
        }
        break;
    }
    if (sector->special& 0x80 )
    {
      player->secretcount++;
      sector->special &= ~0x80 ;
      if (sector->special<32)  
        sector->special=0;     
    }

     
     
     
     
     

  }
}

 
 
 
 
 
 
 
 
 
 
 

boolean         levelTimer;
int             levelTimeCount;
boolean         levelFragLimit;       
int             levelFragLimitCount;  

void P_UpdateSpecials (void)
{
  anim_t*     anim;
  int         pic;
  int         i;

   
  if (levelTimer == true)
  {
    levelTimeCount--;
    if (!levelTimeCount)
      G_ExitLevel();
  }

   
   
   
  if (levelFragLimit == true)   
  {
    int k,m,fragcount,exitflag=false;
    for (k=0;k< 4 ;k++)
    {
      if (!playeringame[k]) continue;
      fragcount = 0;
      for (m=0;m< 4 ;m++)
      {
        if (!playeringame[m]) continue;
          fragcount += (m!=k)?  players[k].frags[m] : -players[k].frags[m];
      }
      if (fragcount >= levelFragLimitCount) exitflag = true;
      if (exitflag == true) break;  
    }
    if (exitflag == true)
      G_ExitLevel();
  }

   
  for (anim = anims ; anim < lastanim ; anim++)
  {
    for (i=anim->basepic ; i<anim->basepic+anim->numpics ; i++)
    {
      pic = anim->basepic + ( (leveltime/anim->speed + i)%anim->numpics );
      if (anim->istexture)
        texturetranslation[i] = pic;
      else
        flattranslation[i] = pic;
    }
  }

   
  for (i = 0; i < (4 *4) ; i++)
    if (buttonlist[i].btimer)
    {
      buttonlist[i].btimer--;
      if (!buttonlist[i].btimer)
      {
        switch(buttonlist[i].where)
        {
          case top:
            sides[buttonlist[i].line->sidenum[0]].toptexture =
              buttonlist[i].btexture;
            break;

          case middle:
            sides[buttonlist[i].line->sidenum[0]].midtexture =
              buttonlist[i].btexture;
            break;

          case bottom:
            sides[buttonlist[i].line->sidenum[0]].bottomtexture =
              buttonlist[i].btexture;
            break;
        }
        S_StartSound((mobj_t *)&buttonlist[i].soundorg,sfx_swtchn);
        memset(&buttonlist[i],0,sizeof(button_t));
      }
    }
}

 
 
 
 
 

 
 
 
 
 

 
void P_SpawnSpecials (void)
{
  sector_t*   sector;
  int         i;
  int         episode;

  episode = 1;
  if ((W_CheckNumForName)( "texture2" , ns_global)  >= 0)
    episode = 2;

   
  levelTimer = false;

  i = M_CheckParm("-avg");    
  if (i && deathmatch)
  {
    levelTimer = true;
    levelTimeCount = 20 * 60 * 35 ;
  }

  i = M_CheckParm("-timer");  
  if (i && deathmatch)
  {
    int time;
    time = atoi(myargv[i+1]) * 60 * 35 ;
    levelTimer = true;
    levelTimeCount = time;
  }

   
  levelFragLimit = false;
  i = M_CheckParm("-frags");   
  if (i && deathmatch)
  {
    int frags;
    frags = atoi(myargv[i+1]);
    if (frags <= 0) frags = 10;   
    levelFragLimit = true;
    levelFragLimitCount = frags;
  }


   
  sector = sectors;
  for (i=0 ; i<numsectors ; i++, sector++)
  {
    if (!sector->special)
      continue;

    if (sector->special& 0x80 )  
      totalsecret++;                  

    switch (sector->special&31)
    {
      case 1:
         
        P_SpawnLightFlash (sector);
        break;

      case 2:
         
        P_SpawnStrobeFlash(sector,15 ,0);
        break;

      case 3:
         
        P_SpawnStrobeFlash(sector,35 ,0);
        break;

      case 4:
         
        P_SpawnStrobeFlash(sector,15 ,0);
        sector->special |= 3<< 5 ;  
        break;

      case 8:
         
        P_SpawnGlowingLight(sector);
        break;
      case 9:
         
        if (sector->special<32)  
          totalsecret++;         
        break;

      case 10:
         
        P_SpawnDoorCloseIn30 (sector);
        break;

      case 12:
         
        P_SpawnStrobeFlash (sector, 35 , 1);
        break;

      case 13:
         
        P_SpawnStrobeFlash (sector, 15 , 1);
        break;

      case 14:
         
        P_SpawnDoorRaiseIn5Mins (sector, i);
        break;

      case 17:
         
        P_SpawnFireFlicker(sector);
        break;
    }
  }

  P_RemoveAllActiveCeilings();   

  P_RemoveAllActivePlats();      

  for (i = 0;i < (4 *4) ;i++)
    memset(&buttonlist[i],0,sizeof(button_t));

   
   

  P_InitTagLists();    

  P_SpawnScrollers();  

  P_SpawnFriction();   

  P_SpawnPushers();    

  for (i=0; i<numlines; i++)
    switch (lines[i].special)
    {
      int s, sec;

       
       
      case 242:
        sec = sides[*lines[i].sidenum].sector-sectors;
        for (s = -1; (s = P_FindSectorFromLineTag(lines+i,s)) >= 0;)
          sectors[s].heightsec = sec;
        break;

       
       
      case 213:
        sec = sides[*lines[i].sidenum].sector-sectors;
        for (s = -1; (s = P_FindSectorFromLineTag(lines+i,s)) >= 0;)
          sectors[s].floorlightsec = sec;
        break;

       
       
      case 261:
        sec = sides[*lines[i].sidenum].sector-sectors;
        for (s = -1; (s = P_FindSectorFromLineTag(lines+i,s)) >= 0;)
          sectors[s].ceilinglightsec = sec;
        break;
   }
}

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

void T_Scroll(scroll_t *s)
{
  fixed_t dx = s->dx, dy = s->dy;

  if (s->control != -1)
    {    
      fixed_t height = sectors[s->control].floorheight +
        sectors[s->control].ceilingheight;
      fixed_t delta = height - s->last_height;
      s->last_height = height;
      dx = FixedMul(dx, delta);
      dy = FixedMul(dy, delta);
    }

   
  if (s->accel)
    {
      s->vdx = dx += s->vdx;
      s->vdy = dy += s->vdy;
    }

  if (!(dx | dy))                    
    return;

  switch (s->type)
    {
      side_t *side;
      sector_t *sec;
      fixed_t height, waterheight;   
      msecnode_t *node;
      mobj_t *thing;

    case sc_side:                    
        side = sides + s->affectee;
        side->textureoffset += dx;
        side->rowoffset += dy;
        break;

    case sc_floor:                   
        sec = sectors + s->affectee;
        sec->floor_xoffs += dx;
        sec->floor_yoffs += dy;
        break;

    case sc_ceiling:                
        sec = sectors + s->affectee;
        sec->ceiling_xoffs += dx;
        sec->ceiling_yoffs += dy;
        break;

    case sc_carry:

       
       
       
       

      sec = sectors + s->affectee;
      height = sec->floorheight;
      waterheight = sec->heightsec != -1 &&
        sectors[sec->heightsec].floorheight > height ?
        sectors[sec->heightsec].floorheight : ((int)0x80000000L) ;

      for (node = sec->touching_thinglist; node; node = node->m_snext)
        if (!((thing = node->m_thing)->flags & MF_NOCLIP) &&
            (!(thing->flags & MF_NOGRAVITY || thing->z > height) ||
             thing->z < waterheight))
          {
             
             
            thing->momx += dx;
            thing->momy += dy;
          }
      break;

    case sc_carry_ceiling:        
      break;
    }
}

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

static void Add_Scroller(int type, fixed_t dx, fixed_t dy,
                         int control, int affectee, int accel)
{
  scroll_t *s = (Z_Malloc)   ( sizeof *s ,  PU_LEVSPEC ,  0 ,  "p_spec.c",2645) ;
  s->thinker.function.acp1 = (actionf_p1) T_Scroll;
  s->type = type;
  s->dx = dx;
  s->dy = dy;
  s->accel = accel;
  s->vdx = s->vdy = 0;
  if ((s->control = control) != -1)
    s->last_height =
      sectors[control].floorheight + sectors[control].ceilingheight;
  s->affectee = affectee;
  P_AddThinker(&s->thinker);
}

 
 
 
 
 
 

static void Add_WallScroller(fixed_t dx, fixed_t dy, const line_t *l,
                             int control, int accel)
{
  fixed_t x = ({int _s,_t=( l->dx ); asm(" cdq": "=d" (_s): "a" (_t)); (_t^_s)-_s;}) , y = ({int _s,_t=( l->dy ); asm(" cdq": "=d" (_s): "a" (_t)); (_t^_s)-_s;}) , d;
  if (y > x)
    d = x, x = y, y = d;
  d = FixedDiv(x, finesine[(tantoangle[FixedDiv(y,x) >> (16 - 11 ) ] + 0x40000000 )
                          >> 19 ]);
  x = -FixedDiv(FixedMul(dy, l->dy) + FixedMul(dx, l->dx), d);
  y = -FixedDiv(FixedMul(dx, l->dy) - FixedMul(dy, l->dx), d);
  Add_Scroller(sc_side, x, y, control, *l->sidenum, accel);
}

 


 
 


 
static void P_SpawnScrollers(void)
{
  int i;
  line_t *l = lines;

  for (i=0;i<numlines;i++,l++)
    {
      fixed_t dx = l->dx >> 5 ;   
      fixed_t dy = l->dy >> 5 ;
      int control = -1, accel = 0;          
      int special = l->special;

       
       
       
       
       
       
       

      if (special >= 245 && special <= 249)          
        {
          special += 250-245;
          control = sides[*l->sidenum].sector - sectors;
        }
      else
        if (special >= 214 && special <= 218)        
          {
            accel = 1;
            special += 250-214;
            control = sides[*l->sidenum].sector - sectors;
          }

      switch (special)
        {
          register int s;

        case 250:    
          for (s=-1; (s = P_FindSectorFromLineTag(l,s)) >= 0;)
            Add_Scroller(sc_ceiling, -dx, dy, control, s, accel);
          break;

        case 251:    
        case 253:    
          for (s=-1; (s = P_FindSectorFromLineTag(l,s)) >= 0;)
            Add_Scroller(sc_floor, -dx, dy, control, s, accel);
          if (special != 253)
            break;

        case 252:  
          dx = FixedMul(dx,((fixed_t)((1<< 16 ) *.09375)) );
          dy = FixedMul(dy,((fixed_t)((1<< 16 ) *.09375)) );
          for (s=-1; (s = P_FindSectorFromLineTag(l,s)) >= 0;)
            Add_Scroller(sc_carry, dx, dy, control, s, accel);
          break;

           
           
        case 254:
          for (s=-1; (s = P_FindLineFromLineTag(l,s)) >= 0;)
            if (s != i)
              Add_WallScroller(dx, dy, lines+s, control, accel);
          break;

        case 255:     
          s = lines[i].sidenum[0];
          Add_Scroller(sc_side, -sides[s].textureoffset,
                       sides[s].rowoffset, -1, s, accel);
          break;

        case 48:                   
          Add_Scroller(sc_side,  (1<< 16 ) , 0, -1, lines[i].sidenum[0], accel);
          break;

        case 85:                   
          Add_Scroller(sc_side, - (1<< 16 ) , 0, -1, lines[i].sidenum[0], accel);
          break;
        }
    }
}

 

 
 
 
 
 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 
 
 
 
 
 

static void Add_Friction(int friction, int movefactor, int affectee)
    {
    friction_t *f = (Z_Malloc)   ( sizeof *f ,  PU_LEVSPEC ,  0 ,  "p_spec.c",2807) ;

    f->thinker.function.acp1 = (actionf_p1) T_Friction;
    f->friction = friction;
    f->movefactor = movefactor;
    f->affectee = affectee;
    P_AddThinker(&f->thinker);
    }

 
 
 
 
 
 

void T_Friction(friction_t *f)
    {
    sector_t *sec;
    mobj_t   *thing;
    msecnode_t* node;

    if (compatibility || !variable_friction)
        return;

    sec = sectors + f->affectee;

     
     

    if (!(sec->special & 0x100 ))
        return;

     
     
     

     

     
     
     

    node = sec->touching_thinglist;  
    while (node)
        {
        thing = node->m_thing;
        if (thing->player &&
            !(thing->flags & (MF_NOGRAVITY | MF_NOCLIP)) &&
            thing->z <= sec->floorheight)
            {
            if ((thing->friction == 0xE800 ) ||      
                (f->friction < thing->friction))
                {
                thing->friction   = f->friction;
                thing->movefactor = f->movefactor;
                }
            }
        node = node->m_snext;
        }
    }

 
 
 

static void P_SpawnFriction(void)
    {
    int i;
    line_t *l = lines;
    register int s;
    int length;      
    int friction;    
    int movefactor;  

    for (i = 0 ; i < numlines ; i++,l++)
        if (l->special == 223)
            {
            length = P_AproxDistance(l->dx,l->dy)>> 16 ;
            friction = (0x1EB8*length)/0x80 + 0xD000;

             
             
             

            if (friction > 0xE800 )        
                movefactor = ((0x10092 - friction)*(0x70))/0x158;
            else
                movefactor = ((friction - 0xDB34)*(0xA))/0x80;
            for (s = -1; (s = P_FindSectorFromLineTag(l,s)) >= 0 ; )
                Add_Friction(friction,movefactor,s);
            }
    }

 
 
 
 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 




 
 
 

static void Add_Pusher(int type, int x_mag, int y_mag, mobj_t* source, int affectee)
    {
    pusher_t *p = (Z_Malloc)   ( sizeof *p ,  PU_LEVSPEC ,  0 ,  "p_spec.c",2959) ;

    p->thinker.function.acp1 = (actionf_p1) T_Pusher;
    p->source = source;
    p->type = type;
    p->x_mag = x_mag>> 16 ;
    p->y_mag = y_mag>> 16 ;
    p->magnitude = P_AproxDistance(p->x_mag,p->y_mag);
    if (source)  
        {
        p->radius = (p->magnitude)<<(16 +1);  
        p->x = p->source->x;
        p->y = p->source->y;
        }
    p->affectee = affectee;
    P_AddThinker(&p->thinker);
    }

 
 
 
 
 
 
 

pusher_t* tmpusher;  

boolean PIT_PushThing(mobj_t* thing)
    {
    if (thing->player &&
        !(thing->flags & (MF_NOGRAVITY | MF_NOCLIP)))
        {
        angle_t pushangle;
        int dist;
        int speed;
        int sx,sy;

        sx = tmpusher->x;
        sy = tmpusher->y;
        dist = P_AproxDistance(thing->x - sx,thing->y - sy);
        speed = (tmpusher->magnitude -
                 ((dist>> 16 )>>1))<<(16 - 7 -1);

         
         

        if ((speed > 0) && (P_CheckSight(thing,tmpusher->source)))
            {
            pushangle = R_PointToAngle2(thing->x,thing->y,sx,sy);
            if (tmpusher->source->type == MT_PUSH)
                pushangle += 0x80000000 ;     
            pushangle >>= 19 ;
            thing->momx += FixedMul(speed,finecosine[pushangle]);
            thing->momy += FixedMul(speed,finesine[pushangle]);
            }
        }
    return true;
    }

 
 
 
 
 

void T_Pusher(pusher_t *p)
    {
    sector_t *sec;
    mobj_t   *thing;
    msecnode_t* node;
    int xspeed,yspeed;
    int xl,xh,yl,yh,bx,by;
    int radius;
    int ht = 0;

    if (!allow_pushers)
        return;

    sec = sectors + p->affectee;

     
     

    if (!(sec->special & 0x200 ))
        return;

     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     

    if (p->type == p_push)
        {

         
         

        tmpusher = p;  
        radius = p->radius;  
        tmbbox[BOXTOP]    = p->y + radius;
        tmbbox[BOXBOTTOM] = p->y - radius;
        tmbbox[BOXRIGHT]  = p->x + radius;
        tmbbox[BOXLEFT]   = p->x - radius;

        xl = (tmbbox[BOXLEFT] - bmaporgx - (32* (1<< 16 ) ) )>> (16 +7) ;
        xh = (tmbbox[BOXRIGHT] - bmaporgx + (32* (1<< 16 ) ) )>> (16 +7) ;
        yl = (tmbbox[BOXBOTTOM] - bmaporgy - (32* (1<< 16 ) ) )>> (16 +7) ;
        yh = (tmbbox[BOXTOP] - bmaporgy + (32* (1<< 16 ) ) )>> (16 +7) ;
        for (bx=xl ; bx<=xh ; bx++)
            for (by=yl ; by<=yh ; by++)
                P_BlockThingsIterator(bx,by,PIT_PushThing);
        return;
        }

     

    if (sec->heightsec != -1)  
        ht = sectors[sec->heightsec].floorheight;
    node = sec->touching_thinglist;  
    for ( ; node ; node = node->m_snext)
        {
        thing = node->m_thing;
        if (!thing->player || (thing->flags & (MF_NOGRAVITY | MF_NOCLIP)))
            continue;
        if (p->type == p_wind)
            {
            if (sec->heightsec == -1)  
                if (thing->z > thing->floorz)  
                    {
                    xspeed = p->x_mag;  
                    yspeed = p->y_mag;
                    }
                else  
                    {
                    xspeed = (p->x_mag)>>1;  
                    yspeed = (p->y_mag)>>1;
                    }
            else  
                {
                if (thing->z > ht)  
                    {
                    xspeed = p->x_mag;  
                    yspeed = p->y_mag;
                    }
                else if (thing->player->viewz < ht)  
                    xspeed = yspeed = 0;  
                else  
                    {
                    xspeed = (p->x_mag)>>1;  
                    yspeed = (p->y_mag)>>1;
                    }
                }
            }
        else  
            {
            if (sec->heightsec == -1)  
                if (thing->z > sec->floorheight)  
                    xspeed = yspeed = 0;  
                else  
                    {
                    xspeed = p->x_mag;  
                    yspeed = p->y_mag;
                    }
            else  
                if (thing->z > ht)  
                    xspeed = yspeed = 0;  
                else  
                    {
                    xspeed = p->x_mag;  
                    yspeed = p->y_mag;
                    }
            }
        thing->momx += xspeed<<(16 - 7 );
        thing->momy += yspeed<<(16 - 7 );
        }
    }

 
 
 
 

mobj_t* P_GetPushThing(int s)
    {
    mobj_t* thing;
    sector_t* sec;

    sec = sectors + s;
    thing = sec->thinglist;
    while (thing)
        {
        switch(thing->type)
            {
          case MT_PUSH:
          case MT_PULL:
            return thing;
          default:
            break;
            }
        thing = thing->snext;
        }
    return 0 ;
    }

 
 
 
 

static void P_SpawnPushers(void)
    {
    int i;
    line_t *l = lines;
    register int s;
    mobj_t* thing;

    for (i = 0 ; i < numlines ; i++,l++)
        switch(l->special)
            {
          case 224:  
            for (s = -1; (s = P_FindSectorFromLineTag(l,s)) >= 0 ; )
                Add_Pusher(p_wind,l->dx,l->dy,0 ,s);
            break;
          case 225:  
            for (s = -1; (s = P_FindSectorFromLineTag(l,s)) >= 0 ; )
                Add_Pusher(p_current,l->dx,l->dy,0 ,s);
            break;
          case 226:  
            for (s = -1; (s = P_FindSectorFromLineTag(l,s)) >= 0 ; )
                {
                thing = P_GetPushThing(s);
                if (thing)  
                    Add_Pusher(p_push,l->dx,l->dy,thing,s);
                }
            break;
            }
    }

 
 
 
 


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
